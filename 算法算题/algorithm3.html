<!--
 * @Autor: hjz
 * @Date: 2020-05-26 20:18:47
 * @LastEditors: hjz
 * @LastEditTime: 2020-06-17 18:04:38
 * @Description: leetcode
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // TODO: 数据结构
        function ListNode(x) {
            this.val = x;
            this.next = null;
        }
        function LinkList() {
            // this.head = new ListNode(null);
            this.head = null;
            this.add = function (v) {
                let node = new ListNode(v);
                node.next = this.head;
                this.head = node;
            }
            this.add2 = function (arr) {
                for (let i = 0; i < arr.length; i++) {
                    let node = new ListNode(arr[i]);
                    node.next = this.head;
                    this.head = node;
                }
            }
            this.add2_tail = function (arr) {
                let curNode = this.head;
                for (let i = 0; i < arr.length; i++) {
                    let node = new ListNode(arr[i]);
                    if (curNode === null) {
                        this.head = node;
                        curNode = node;
                    } else {
                        curNode.next = node;
                        curNode = curNode.next;
                    }
                }
            }
        }
    </script>
    <script>
        /*
                // TODO: 1. 两数之和
                var twoSum = function (nums, target) {
                    let map = {}; // 哈希
                    for (let i = 0; i < nums.length; i++) {
                        if (!map[nums[i]]) {
                            map[nums[i]] = i;
                        } else {
                            map[nums[i] + ' '] = i;
                        }
                    }
                    let re = [];
                    for (let i = 0; i < nums.length; i++) {
                        let num = target - nums[i]
                        if (map[num] && i !== map[num]) {
                            return [i, map[num]];
                        } else if (map[num + ' '] && i !== map[num + ' ']) {
                            return [i, map[num + ' ']]
                        }
                    }
                };
        
                // TODO: 51. N皇后
                // 当且仅当n = 1或n ≥ 4时问题有解
                // 输入4，输出 [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
                function solveNQueens(n) {
                    let arr = new Array(n);
                    let res = [];
                    _solveNQueens(arr, 0, n - 1, res);
                    if (res.length === 0) {
                        return [];
                    }
                    return res;
                }
                // k代表当前第i行，k和n都是代表下标
                function _solveNQueens(arr, k, n, res) {
                    if (k > n) {
                        // console.log(arr); // 输出n皇后结果
                        let temp = [];
                        for (let i = 0; i < arr.length; i++) {
                            let str = '';
                            for (let k = 0; k <= n; k++) {
                                if (arr[i] !== k) {
                                    str += '.';
                                } else {
                                    str += 'Q';
                                }
                            }
                            temp[i] = str;
                        }
                        res.push([...temp]);
                        temp = null;
                        return;
                    }
                    // 当前遍历每一列！！！逐一尝试每个位置放置皇后
                    for (let i = 0; i <= n; i++) { // 因为n代表
                        // 使用回溯递归法，循环中递归
                        arr[k] = i;
                        if (!!check(arr, k)) {
                            // 如果符合，就进入下一层的递归中，如果没有就下一列尝试
                            _solveNQueens(arr, k + 1, n, res);
                        }
                    }
                }
                function check(arr, n) {
                    // 注意，参数n应该是下标，0-(n-1);
                    // 逐行遍历，判断当前n行是否符合要求
                    for (let i = 0; i < n; i++) { // 遍历下标为n的前几行
                        if (Math.abs(arr[i] - arr[n]) === n - i || arr[i] === arr[n]) {
                            // 对角和同列否掉，因为逐行遍历，所以不用担心同行
                            return false;
                        }
                    }
                    return true;
                }
                // console.log(solveNQueens(4));
        
        
                // TODO: 53. 最大子序和
                var maxSubArray = function (nums) {
                    if (nums.length === 0) {
                        return 0;
                    }
                    let res = new Array(nums.length);
                    res[0] = nums[0];
                    for (let i = 1; i < nums.length; i++) {
                        if (res[i - 1] < 0) {
                            res[i] = nums[i];
                        } else if (nums[i] + res[i - 1] > 0) {
                            res[i] = nums[i] + res[i - 1];
                        } else {
                            res[i] = nums[i];
                        }
                    }
                    let max = res[0];
                    res.forEach((item) => {
                        if (item > max) {
                            max = item;
                        }
                    })
                    return max;
                };
                // let nums = [-2,1,-3,4,-1,2,1,-5,4];
                // console.log(maxSubArray(nums));
        
                // TODO: 2. 两数相加
                // 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
                // 方法一，将两个链表转化为数字相加，但是问题在于如果数字很大，会转变成科学计数法！num = num.toLocaleString()
                // 方法二，模拟加法！！！逐位相加！！！因为是逆序，也正好是从低位到高位相加
        
                var addTwoNumbers = function (l1, l2) {
                    if (l1 === null || l2 === null) {
                        return 0;
                    }
                    let head = new ListNode(null);
                    // head.next = null; // 其实链表中的断点，已经默认next给null了
                    let tail = head;
                    let flag = 0; // 代表进位！
                    while (l1 || l2 || flag) { // 如果flag为1，则需要高位+1
                        let num1 = l1 ? l1.val : 0;
                        let num2 = l2 ? l2.val : 0;
                        let sum = num1 + num2 + flag;
                        flag = sum >= 10 ? 1 : 0;
                        // 使用尾插法！
                        tail.next = new ListNode(sum % 10);
                        tail = tail.next;
                        l1 = l1 ? l1.next : null;
                        l2 = l2 ? l2.next : null;
                    }
                    return head.next;
                };
                // let list1 = new LinkList();
                // // let arr = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];
                // let arr = [2, 4, 3];
                // list1.add2(arr);
                // let list2 = new LinkList();
                // let arr2 = [5, 6, 4];
                // list2.add2(arr2);
                // console.log(addTwoNumbers(list1.head, list2.head));
        
                // TODO: 3. 无重复字符的最长子串
                // 如"abcabcbb" 输出: 3  解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
                // 思路，滑动窗口，也是类似动态规划，re[i]代表第i个字符（包含此字符）往后的最长子串
                // 利用set来判断子串是否有重合。注意！为了set可以重复使用，也就是窗口下移的时候，就移出前一个字符，保留后续的set！同时指针指向也保留
                var lengthOfLongestSubstring = function (s) {
                    if (!s) {
                        return 0;
                    }
                    let len = s.length;
                    let set = new Set();
                    let re = new Array(len).fill(0); // 可以不是用数组
                    let p = 0; // 指针指向子序的结尾
                    let max = 0;
                    for (let i = 0; i < len; i++) {
                        if (i !== 0) {
                            // 滑动窗口移动，删除前一个字符
                            set.delete(s.charAt(i - 1));
                        }
                        while (!set.has(s.charAt(p)) && p < len) {
                            set.add(s.charAt(p));
                            p++;
                        }
                        re[i] = p - i; // 理应+1，但已经p++所以不用
                        if (max < re[i]) {
                            max = re[i];
                        }
                    }
                    return max;
                };
                // let s = 'abcabcbb';
                // console.log(lengthOfLongestSubstring(s));
        
                // TODO: 4. 寻找两个正序数组的中位数
                // 利用归并算法的合并方法，将两个有序数组合并成一个数组
                var findMedianSortedArrays = function (nums1, nums2) {
                    let len1 = nums1.length;
                    let len2 = nums2.length;
                    let mid = (len1 + len2) / 2;
                    let i = 0, j = 0;
                    let count = 0; // 相应的排序，当前是第count大
                    let n = 0;
                    let re = [];
                    while (i < len1 && j < len2) {
                        if (nums1[i] <= nums2[j]) {
                            n = nums1[i];
                            i++;
                        } else {
                            n = nums2[j];
                            j++;
                        }
                        count++;
                        if (mid <= count && mid + 1 >= count) {
                            re.push(n);
                        }
                    }
                    if (i >= len1) {
                        while (j < len2) {
                            n = nums2[j];
                            j++;
                            count++;
                            if (mid <= count && mid + 1 >= count) {
                                re.push(n);
                            }
                        }
                    }
                    if (j >= len2) {
                        while (i < len1) {
                            n = nums1[i];
                            i++;
                            count++;
                            if (mid <= count && mid + 1 >= count) {
                                re.push(n);
                            }
                        }
                    }
                    let flag = (len1 + len2) % 2 === 0; // 偶数
                    return flag ? (re[0] + re[1]) / 2 : re[0];
                };
                // let nums1 = [1, 5, 8];
                // let nums2 = [2, 3, 4];
                // console.log(findMedianSortedArrays(nums1, nums2));
        
                // TODO: 5. 最长回文子串
                // 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
                // 因为一个回文去掉两头后，依然是个回文！！！可以使用动态规划
                // dp[i,j] 代表 s[i...j]也就是字符串中i到j是否是回文。
                // dp[i,j] = (s[i] === s[j]) and dp[i+1][j-1] 也就是两头如果相等，就需要去掉两头看剩余的是否也满足！
                // 边界条件，(j-1)-(i+1)+1<2，注意假定回文必须大于2这样才有意义。整理可得j-i<3，也就是s[i..j]长度为2或3的时候如果s[i]=s[j]就不需要继续检查其子串是否是回文！
                // dp[i,j] = (s[i] === s[j]) and (j-i<3 or dp[i+1][j-1])
                // 上文的所有讨论是建立在子串长度大于 22 的前提之上的，我们还需要考虑动态规划中的边界条件，即子串的长度为 11 或 22。对于长度为 11 的子串，它显然是个回文串；对于长度为 22 的子串，只要它的两个字母相同，它就是一个回文串。
                // 最终的答案即为所有 P(i, j) = \text{true}P(i,j)=true 中 j-i+1j−i+1（即子串长度）的最大值。
                // 从长度较短的字符串向长度较长的字符串进行转移的
                // 动态规划的好处就是，利用状态转移方程，快速知道哪些子串是回文！
                // 初始化！单个字符一定是回文，也就是对角线为1
                // 填表只需填上右三角即可，因为i<j。因为dp[i+1][j-1] 也就是dp[i][j]是参考左下角的值！所以不能一行一行遍历了！要一列一列得填表！！！
                // 注意！！！填表的顺序，其实是基于参考位置的！！！并且一般是由子问题到整体，填表也是从小到大填写
                var longestPalindrome = function (s) {
                    if (!s) {
                        return "";
                    }
                    let len = s.length;
                    let m = [];
                    // 创建二维数组
                    for (let i = 0; i < len; i++) {
                        m[i] = [];
                    }
                    let ans = s[0]; // 最起码也有个单个字符！！
                    // 一列一列遍历
                    for (let j = 0; j < len; j++) {
                        for (let i = 0; i < j; i++) {
                            if (s[i] === s[j]) {
                                if (j - i < 3 || m[i + 1][j - 1]) {
                                    // 因为j-i<3所以不怕越界！
                                    m[i][j] = true;
                                    if (j - i + 1 > ans.length) {
                                        ans = s.slice(i, j + 1);
                                    }
                                } else {
                                    m[i][j] = false;
                                }
                            } else {
                                m[i][j] = false;
                            }
                        }
                    }
                    return ans;
                };
                // let s = "babad";
                // console.log(longestPalindrome(s));
        
                // TODO: 6. Z字形变换
                // L     D     R
                // E   O E   I I
                // E C   I H   N
                // T     S     G
                // 然后再从左到右遍历输出
                // 思路，模拟法，用numRows个数组承接！！！因为到时也是每行输出，只需逐个数组遍历即可
                // 使用一个flag，如果到底则-1，如果到顶就+1。保证数组间上下轮流迭代。
                var convert = function (s, numRows) {
                    // 当numRows为1的时候，这个太特别了，直接返回s即可！
                    if (numRows === 1) {
                        return s;
                    }
                    let m = [];
                    for (let i = 0; i < numRows; i++) {
                        m[i] = []; // 使用numRows个数组承接这些字符
                    }
                    let index = 0;
                    let row = 0;
                    let flag = 1;
                    // 注意，一下方法，无法处理numRows为1的情况！！！
                    while (index < s.length) {
                        // 遇到顶或者底，就反转
                        if (row === 0) {
                            flag = 1;
                        } else if (row === numRows - 1) {
                            flag = -1;
                        }
                        m[row].push(s[index]);
                        row += flag;
                        index++;
                    }
                    let re = '';
                    for (let i = 0; i < numRows; i++) {
                        re += m[i].join("");
                    }
                    return re;
                };
                // // let s = 'LEETCODEISHIRING';
                // let s = 'LEETCODEISHIRING';
                // // let numRows = 4;
                // let numRows = 1;
                // console.log(convert(s,numRows));
        
                // TODO: 7. 整数反转
                // 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
                // 如-123 -> -321, 120->21
                // 这道题的难点在于溢出问题，数字大了之后会变成科学计数法！
                // 我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
                var reverse = function (x) {
                    let str = x + '';
                    let arr = str.split("");
                    let flag = 1;
                    if (arr[0] === '-') {
                        flag = -1;
                        arr.shift();
                    }
                    arr.reverse();
                    let re = arr.join("");
                    if (re > Math.pow(2, 31) - 1 || re < Math.pow(-2, 31) + 1) {
                        return 0;
                    } else {
                        return re * flag;
                    }
                };
                // let x = -7483648123123213;
                // console.log(reverse(x));
                // console.log(Math.pow(2,31));
                // console.log(7483648123123213>7483648123123212);
        
                // TODO: 8. 字符串转换整数 (atoi)
                // 注意，这道题不能用parseInt因为整数不能超过Math.pow(2,31)
                var myAtoi = function (str) {
                    if (!str) {
                        return 0;
                    }
                    str = str.trim();
                    let flag = 1;
                    if (str[0] === '-' || str[0] === '+') {
                        flag = str[0] === '-' ? -1 : 1;
                        str = str.slice(1);
                    }
                    let re = '';
                    for (let i = 0; i < str.length; i++) {
                        if (str[i] <= 9 && str[i] >= 0 && str[i] !== ' ') { // 注意，这里如果为空串，则比较的时候会默认为0！！！！
                            re += str[i];
                        } else {
                            break;
                        }
                    }
                    re = flag * re;
                    let INT_MAX = Math.pow(2, 31) - 1;
                    let INT_MIN = Math.pow(-2, 31);
                    if (re >= INT_MAX) {
                        return INT_MAX;
                    }
                    if (re <= INT_MIN) {
                        return INT_MIN;
                    }
                    return re;
                };
                // let str = "   +0 123";
                // console.log(myAtoi(str));
        
                // TODO: 9. 回文数
                // 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
                var isPalindrome = function (x) {
                    if (!x) {
                        return true;
                    }
                    return x + "" === (x + "").split("").reverse().join("");
                };
        
                // TODO: 10. 正则表达式匹配
                var isMatch = function (s, p) {
                    if (!s && !p) {
                        return true;
                    }
                    if (!p && p.length === 0) {
                        return false;
                    }
                    const reg = new RegExp('^' + p + '$');
                    return reg.test(s);
                };
        
                // TODO: 11. 盛最多水的容器
                // 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
                // arr[i,j]水位等于(j-i)*min(arr[i],arr[j]);
                // 思路，是双指针指向首位，因为短板效应，所以每次移动指针，都移动最小值的那个指针！（规避短板！）
                var maxArea = function (height) {
                    if (!height && height.length === 0) {
                        return 0;
                    }
                    let len = height.length;
                    let i = 0;
                    let j = len - 1;
                    let area = 0;
                    let max = 0;
                    while (i <= j) {
                        area = (j - i) * Math.min(height[i], height[j]);
                        max = Math.max(area, max);
                        if (height[i] > height[j]) {
                            j--;
                        } else {
                            i++;
                        }
                    }
                    return max;
                };
                // let height = [1,8,6,2,5,4,8,3,7];
                // console.log(maxArea(height));
        
                // TODO: 12. 整数转罗马数字
        
                // TODO: 13. 罗马数字转整数
        
                // TODO: 14. 最长公共前缀
                // ["flower","flow","flight"] 输出: "fl"
                // 思路，水平扫描。两个比较获得一个公共前缀，再和下一个比较，也就是基于上一个结果比较，可以避免重复比较
                // LCP(S1...Sn) = LCP(LCP(LCP(S1,S2),S3)...Sn);  
                var longestCommonPrefix = function (strs) {
                    if (strs.length === 0) {
                        return "";
                    }
                    let res = strs[0];
                    for (let i = 1; i < strs.length; i++) {
                        let index = 0;
                        let temp = "";
                        // 注意，这里不允许无限循环，很容易越界，一般最好不要使用无限循环的
                        while (index < strs[i].length) {
                            if (strs[i][index] === res[index]) {
                                temp += strs[i][index];
                                index++;
                            } else {
                                break;
                            }
                        }
                        res = temp;
                    }
                    return res;
                };
                // let strs = ["flower", "flow", "flight"];
                // // let strs = [];
                // console.log(longestCommonPrefix(strs));
        
                // TODO: 15. 三数之和
                // 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
                // 给定数组 nums = [-1, 0, 1, 2, -1, -4]   [-1, 0, 1],[-1, -1, 2]
                // 思路，需要先排序！！！三数之和为0，必定出现在0的左右，有正有负。
                // 从左到右遍历数组，假定当前是nums[i]且小于0，那么剩下的值，则在右方寻找！！！右方的值必定大，退出循环！
                // 还有个要点，就是要规避重复，就是在一层循环中nums[i], nums[left], nums[right]三者不能和对应的前者相同，如nums[i]!=nums[i-1]
                var threeSum = function (nums) {
                    let len = nums.length;
                    if (!len || len < 3) {
                        return [];
                    }
                    nums.sort((a, b) => a - b);
                    let re = [];
                    // 此题思路，相当于求nums[left]+nums[right]=-nums[i];
                    for (let i = 0; i < len; i++) {
                        // 注意，nums[i]是不能大于0的！！！
                        // if (nums < 0) 大忌！！！！！！千万不要拿数组进行比较！！！！！！！！会非常耗时
                        if (nums[i] > 0) {
                            break;
                        }
                        if (i > 0 && nums[i] === nums[i - 1]) {
                            // 已经重复了！
                            continue;
                        }
                        // 在右侧的两段！！
                        let left = i + 1;
                        let right = len - 1;
                        while (left < right) {
                            if (nums[left] + nums[right] > -nums[i]) {
                                // 从小到大排序，如果大了，就从右边退一步
                                right--;
                            } else if (nums[left] + nums[right] < -nums[i]) {
                                left++;
                            } else {
                                // 注意！！这里的去重，是在获得对应结果的时候，才去去重的！！！！！未确定结果的时候是不能随便left++  right--的                        // 去重！！！思路在于nums[i]当前层中的left和right都不允许有重复
                                while (left < right && nums[left] === nums[left + 1]) {
                                    left++;
                                }
                                while (left < right && nums[right] === nums[right - 1]) {
                                    right--;
                                }
                                re.push([nums[i], nums[left], nums[right]]);
                                // 继续下一次寻找
                                left++;
                                right--;
                            }
                        }
                    }
                    return re;
                };
                // let nums = [-1, 0, 1, 2, -1, -4];
                // let nums = [0, 0, 0, 0];
                // let nums = [-2, 0, 1, 1, 7, 8];
                // console.log(threeSum(nums));
        
                // TODO: 16. 最接近的三数之和
                // 这道题的思路和上一道相似！！！
                // 然后每次固定一个元素，再去寻找另外两个元素，也就是双指针！！！！
                // 思路，先排序，然后nums[i],nums[left],nums[right]三者寻找。
                // 这道题不能用滑动窗口的做法！！！因为有正负数的原因！！！
                var threeSumClosest = function (nums, target) {
                    if (!nums || nums.length < 3) {
                        return [];
                    }
                    nums.sort((a, b) => a - b);
                    let len = nums.length;
                    let re = nums[0] + nums[1] + nums[2];
                    // 利用滑动窗口
                    for (let i = 0; i < len; i++) {
                        let left = i + 1;
                        let right = len - 1;
                        if (i > 0 && nums[i] === nums[i - 1]) {
                            continue; // 没必要重复
                        }
                        while (left < right) {
                            // 注意，这个去重是要在获得结果的时候才去重的，
                            // while (left < right && nums[left] === nums[left + 1]) {
                            //     left++;
                            // }
                            // while (left < right && nums[right] === nums[right - 1]) {
                            //     right--;
                            // }
                            let sum = nums[i] + nums[left] + nums[right];
                            if (Math.abs(target - sum) < Math.abs(target - re)) {
                                re = sum;
                            }
                            // 进行下一次遍历，慢慢逼近target
                            if (sum > target) {
                                right--;
                            } else {
                                left++;
                            }
                        }
                    }
                    return re;
                };
                // let nums = [-1,0,1,1,55];
                // console.log(threeSumClosest(nums, 3));
        
        
                // TODO: 17. 电话号码的字母组合
                // 相当于全排列，使用循环中递归的方式进行全排列！！！
                var letterCombinations = function (digits) {
                    if (!digits || digits.length === 0) {
                        return [];
                    }
                    let map = new Map();
                    map.set("2", "abc");
                    map.set("3", "def");
                    map.set("4", "ghi");
                    map.set("5", "jkl");
                    map.set("6", "mno");
                    map.set("7", "pqrs");
                    map.set("8", "tuv");
                    map.set("9", "wxyz");
                    digits = digits.split("");
                    let arr = [];
                    for (let i = 0; i < digits.length; i++) {
                        let temp = map.get(digits[i]);
                        if (temp) {
                            // 必须map存在才添加！
                            // arr.push((temp+"").split(""));
                            arr.push(temp); // 注意，temp是字符串
                        }
                    }
                    let result = [];
                    // let arr = [[1, 2, 3], [1, 2, 3]];
                    _letterCombinations(arr, '', result, 0);
                    return result;
                };
                function _letterCombinations(arr, str, result, index) {
                    // 结束条件
                    if (str.length >= arr.length) {
                        result.push(str);
                        return result;
                    }
                    for (let i = 0; i < arr[index].length; i++) {
                        str += arr[index][i];
                        _letterCombinations(arr, str, result, index + 1);
                        // 走到这一步代表第i个字符的组合已经完成，需要先回溯原来的状态，再装上i+1的字符组合进入下一层递归。
                        str = str.slice(0, str.length - 1);
                    }
                    return result; // 其实可以不返回，因为result是指针传递，会中途保留的
                }
                // let digits = '123';
                // console.log(letterCombinations(digits));
        
                // TODO: 番外. 求全排列！！！
                // 思路，递归中用循环，然后递归结束后回溯，进入下一层递归
                // 入参arr = [[1, 2, 3], [1, 2, 3]];
                function Permutation(arr) {
                    if (!arr || arr.length === 0) {
                        return [];
                    }
                    let res = []; // 地址传递，为了获得最后的结果
                    let index = 0; // 这个表示当前全排列的第index层
                    let str = ''; // 表示当前的字符串，每次全排列一次都push进入res中
                    Permutate(arr, str, res, index);
                    return res;
                }
                function Permutate(arr, str, res, index) {
                    // 结束条件，当str满足全排列中的其中一个值的要求，就push进结果result中
                    if (str.length >= arr.length) {
                        res.push(str);
                        return;
                    }
                    // 递归中循环，注意当前层
                    // 其中的思路是，每次递归都是将一层中的所有值挨个取一次，然后进入下一层递归中继续取。下一层递归结束后，就回溯，继续取当前的下一个值
                    for (let i = 0; i < arr[index].length; i++) {
                        str += arr[index][i];
                        // index需要+1，因为进入下一层遍历。str变动之后带往下一层
                        Permutate(arr, str, res, index + 1);
                        str = str.slice(0, str.length - 1); //回溯
                    }
                    return;
                }
                // let arr = [[1, 2, 3], [1, 2, 3]];
                // console.log(Permutation(arr));
        
                // TODO: 18. 四数之和
                // 思路，双指针再双指针，第一次双指针确定外围，第二次双指针在内围 
                // 使用四个指针(a<b<c<d)。固定最小的a和b在左边，c=b+1,d=_size-1 移动两个指针包夹求解。
                // 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)
                // 也就是最左的两个指针ab是固定循环的，然后cd则是根据sum来变动切换的。
                // 就相当于ab固定一个值，cd左右指针，这就和三数之和一样了！！！！！
                var fourSum = function (nums, target) {
                    if (!nums || nums.length < 4) {
                        return [];
                    }
                    let len = nums.length;
                    let res = [];
                    // 一样要先排序！
                    nums.sort((a, b) => a - b);
                    // 注意，因为至少是4数，所以最左边的指针不能超过len-3
                    for (let a = 0; a < len - 3; a++) {
                        if (a > 0 && nums[a] === nums[a - 1]) {
                            continue; // 去重！！！
                        }
                        for (let b = a + 1; b < len - 2; b++) {
                            if (b > a + 1 && nums[b] === nums[b - 1]) {
                                continue; // 去重！！！
                            }
                            // 注意，以上就是相当于固定了ab的值，剩下两个cd指针去寻找答案，类似三数之和的做法
                            let c = b + 1;
                            let d = len - 1;
                            while (c < d) {
                                let sum = nums[a] + nums[b] + nums[c] + nums[d];
                                if (sum > target) {
                                    d--;
                                } else if (sum < target) {
                                    c++;
                                } else {
                                    // 找到答案之后才能去重！！！！
                                    while (c < d && nums[c] === nums[c + 1]) {
                                        c++;
                                    }
                                    while (c < d && nums[d] === nums[d - 1]) {
                                        d--;
                                    }
                                    res.push([nums[a], nums[b], nums[c], nums[d]])
                                    c++;
                                    d--;
                                }
                            }
                        }
                    }
                    return res;
                };
        
                // TODO: 19. 删除链表的倒数第N个节点
                // 思路，常规一般都是两次遍历算法
                // 你能尝试使用一趟扫描实现吗？
                // 思路，利用快慢指针！！！
                // 注意！！！！！！！这里有个坑！！！就是链表只有一个的时候，求倒数第一个！这导致慢指针无法指向其前一个！！！
                // 解决方案是添加一个空节点！！！
                var removeNthFromEnd = function (head, n) {
                    if (head === null) {
                        return null;
                    }
                    // 添加一个空节点
                    let nullNode = new ListNode(null);
                    nullNode.next = head;
                    head = nullNode;
                    let slow = head;
                    let fast = head;
                    // 快指针先行n-1个。为了获取倒数第n个的前一个
                    for (let i = 0; i < n + 1; i++) {
                        // 有了空结点，这里就不会越界了！
                        fast = fast.next;
                    }
                    while (fast !== null) {
                        fast = fast.next;
                        slow = slow.next;
                    }
                    // 当退出循环时，slow则指向倒数第n个结点的前一个！！！
                    slow.next = slow.next.next;
                    return head.next;
                };
                // let list = new LinkList();
                // // list.add2_tail([1, 2, 3, 4, 5]);
                // list.add2_tail([1]);
                // // console.log(list.head);
                // console.log(removeNthFromEnd(list.head,1));
        
        
        
                // TODO: 20. 有效的括号
                // 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
                // 思路，利用栈！！！
                var isValid = function (s) {
                    if (!s || s.length === 0) {
                        return true;
                    }
                    let map = new Map();
                    map.set('(', ')');
                    map.set('{', '}');
                    map.set('[', ']');
                    let stack = new Array();
                    let index = 0;
                    for (let i = 0; i < s.length; i++) {
                        if (['(', '[', '{'].includes(s[i])) {
                            stack.push(s[i]);
                            continue;
                        } else {
                            let str = stack.pop();
                            if (s[i] === map.get(str)) {
                                continue;
                            } else {
                                return false;
                            }
                        }
                    }
                    return stack.length === 0;
                };
                // let s = '([{}])';
                // // let s = "()[]{}";
                // console.log(isValid(s));
        
                // TODO: 21. 合并两个有序链表
                // 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
                var mergeTwoLists = function (l1, l2) {
                    if (l1 === null && l2 === null) {
                        return null;
                    }
                    let cur1 = l1;
                    let cur2 = l2;
                    let re = new ListNode(null); // 利用虚拟头部
                    let tail = re;
                    while (cur1 !== null && cur2 !== null) {
                        if (cur1.val < cur2.val) {
                            tail.next = cur1;
                            tail = tail.next;
                            cur1 = cur1.next;
                        } else {
                            tail.next = cur2;
                            tail = tail.next;
                            cur2 = cur2.next;
                        }
                    }
                    if (cur1 === null) {
                        tail.next = cur2;
                    } else if (cur2 === null) {
                        tail.next = cur1;
                    }
                    return re.next;
                };
        
                // TODO: 22. 括号生成
                // 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
                // 如n=3，["((()))","(()())","(())()","()(())","()()()"]
                // 思路，使用深度优先遍历，递归回溯。将括号的生成比作一棵树的生成！！！左子树代表"("，右子树代表")"
                // 左右括号如同左右子树！！！！"((()))"无非就是"左左左右右右"
                // 因为字符特性，不是引用传值，无需回溯。
                var generateParenthesis = function (n) {
                    if (n <= 0) {
                        return [];
                    }
                    let result = [];
                    let curStr = '';
                    // let hasLeft = n;
                    // let hasRight = n;
                    // _generateParenthesis(result, curStr, hasLeft, hasRight);
                    let useLeft = 0;
                    let useRight = 0;
                    _generateParenthesis2(result, curStr, useLeft, useRight, n);
                    return result;
                };
                // 减法
                function _generateParenthesis(result, curStr, hasLeft, hasRight) {
                    if (hasLeft === 0 && hasRight === 0) {
                        // 结束条件是在于剩余的左右括号都为0，刚好构成！
                        // 在左边和右边剩余的括号数都等于 0的时候结算。
                        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯
                        result.push(curStr);
                        return;
                    }
                    if (hasLeft > hasRight) {
                        // 注意，这里是剪枝！！！剩余的右括号不足以弥补左括号
                        return;
                    }
                    if (hasLeft > 0) {
                        _generateParenthesis(result, curStr + '(', hasLeft - 1, hasRight);
                    }
                    if (hasRight > 0) {
                        _generateParenthesis(result, curStr + ')', hasLeft, hasRight - 1);
                    }
                }
                // 加法
                function _generateParenthesis2(result, curStr, useLeft, useRight, n) {
                    if (useLeft === n && useRight === n) {
                        // 结束条件是在于剩余的左右括号都为0，刚好构成！
                        result.push(curStr);
                        return;
                    }
                    if (useLeft < useRight) {
                        // 注意，这里是剪枝！！！
                        // 因为每个左括号至多对应一个右括号，使用了n个左括号最多只能n个右括号！！！否则就是(()))
                        // 但是，就算左括号用得多，(()，可这不违反规定！！！后续还能补上！
                        return;
                    }
                    if (useLeft < n) {
                        _generateParenthesis2(result, curStr + '(', useLeft + 1, useRight, n);
                    }
                    if (useRight < n) {
                        _generateParenthesis2(result, curStr + ')', useLeft, useRight + 1, n);
                    }
                }
                // console.log(generateParenthesis(5));
        
                // TODO: 23. 合并K个排序链表（困难）
                // 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。
                // 思路，因为k个都是有序的，可以用归并排序的思路进行。
                var mergeKLists = function (lists) {
                    if (lists.length === 0) {
                        return null;
                    }
                    return _merge(lists, 0, lists.length - 1);
                };
                // 分支算法！！！先分两半，再单独处理，最后再合并
                function _merge(lists, left, right) {
                    // 每个子序列只要有两个以上，就需要分支
                    if (left === right) {
                        // 分到只剩最后一个的时候，则返回！！！
                        // 无法分的时候就返回！
                        return lists[left];
                    }
                    // 因为有个mid+1，很可能越界！！！越界则是返回null
                    if (left > right) {
                        return null;
                    }
                    let mid = Math.floor((left + right) / 2);
                    return _mergeKLists(_merge(lists, left, mid), _merge(lists, mid + 1, right));
                }
                // 两两合并
                function _mergeKLists(list1, list2) {
                    if (list1 === null || list2 === null) {
                        return list1 === null ? list2 : list1;
                    }
                    let re = new ListNode(null);
                    let tail = re;
                    let cur1 = list1;
                    let cur2 = list2;
                    while (cur1 !== null && cur2 !== null) {
                        if (cur1.val < cur2.val) {
                            tail.next = cur1;
                            cur1 = cur1.next;
                        } else {
                            tail.next = cur2;
                            cur2 = cur2.next;
                        }
                        tail = tail.next;
                    }
                    tail.next = cur1 === null ? cur2 : cur1;
                    return re.next;
                }
                // let list1 = new LinkList();
                // let list2 = new LinkList();
                // let list3 = new LinkList();
                // list1.add2_tail([1, 4, 5]);
                // list2.add2_tail([1, 3, 4]);
                // list3.add2_tail([2, 6]);
                // console.log(_mergeKLists(list1.head, list2.head));
        
                // TODO: 24. 两两交换链表中的节点
                // 给定 1->2->3->4, 你应该返回 2->1->4->3
                var swapPairs = function (head) {
                    if (head === null) {
                        return null;
                    }
                    let nullNode = new ListNode(null);
                    nullNode.next = head;
                    head = nullNode;
                    let preNode = nullNode;
                    let curNode = head.next;
                    while (curNode !== null && curNode.next !== null) {
                        let first = curNode;
                        let second = curNode.next;
                        preNode.next = second;
                        first.next = second.next;
                        second.next = first;
                        // 一次进两步！
                        preNode = preNode.next.next;
                        curNode = first.next;
                    }
                    return head.next;
                };
                // let list = new LinkList();
                // list.add2_tail([1,2,3,4,5]);
                // console.log(swapPairs(list.head));
        
                // TODO: 25. K 个一组翻转链表
                // 这只是上面的一个升级版，上面是两个为一组的翻转！
                var reverseKGroup = function (head, k) {
                    // 添加空节点，方便获取pre的结点
                    let nullNode = new ListNode(null);
                    nullNode.next = head;
                    let tail = nullNode;
                    let pre = nullNode;
                    // 先切分链表，断尾并获得尾部对接的下一个结点
                    while (tail !== null) {
                        for (let i = 0; i < k && tail !== null; i++) {
                            // 遍历k次
                            tail = tail.next;
                        }
                        if (tail === null) {
                            break; // 证明不构成k个一组
                        }
                        let nextNode = tail.next; // 保存下一组的开头
                        let start = pre.next; // 注意，这个在翻转前是头部，而翻转后则是尾部！！！
                        // 断尾！
                        tail.next = null;
                        pre.next = listReverse(start); // 因为断尾了，就相当于一个子串进行翻转
                        start.next = nextNode;
                        // 注意，pre和tail是同步位置的
                        pre = start;
                        tail = pre;
                    }
                    return nullNode.next;
                };
                // 一组，头插法可以实现翻转！！！！
                function listReverse(start) {
                    let head = start;
                    let curNode = start.next;
                    start.next = null; // 头插法，第一个即是结尾那个！
                    while (curNode !== null) {
                        let node = curNode.next;
                        curNode.next = head;
                        head = curNode;
                        curNode = node;
                    }
                    return head;
                }
                // let list = new LinkList();
                // list.add2_tail([1, 2, 3, 4, 5]);
                // console.log(listReverse(list.head)); 
        
                // TODO: 26. 删除排序数组中的重复项
                // 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
                // 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
                var removeDuplicates = function (nums) {
                    // let set = new Set(nums);
                    // return [...set]
                    let pre = nums[0];
                    let len = nums.length;
                    for (let i = 1; i < nums.length; i++) {
                        if (pre === nums[i]) {
                            nums.splice(i, 1);
                            i--;
                        } else {
                            pre = nums[i];
                        }
                    }
                    return nums.length;
                };
                // 要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。
                // 使用双指针，一个指针去寻找不同的值，一个指针指向上一个保存下来的值
                var removeDuplicates2 = function (nums) {
                    if (!nums || nums.length === 0) {
                        return 0;
                    }
                    let pre = 0;
                    let cur = 1; // 因为是产出重复项，必须要错开来找！
                    while (cur < nums.length) {
                        if (nums[cur] === nums[pre]) {
                            cur++; // 如果重复就继续递增
                        } else {
                            // 实际上，pre可以和cur重合，一旦重合就相当于不改变数组，而下一次自然会因为相等而cur++
                            nums[pre + 1] = nums[cur]; // pre+1相当于保留pre
                            pre++;
                        }
                    }
                    return pre + 1;
                };
                // console.log(removeDuplicates([1, 1, 2, 2, 3]));
        
                // TODO: 27. 移除元素
                // 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
                // 思路还是和上一道题一样，利用双指针。（尽量不要使用splice）
                var removeElement = function (nums, val) {
                    if (!nums || nums.length === 0) {
                        return 0;
                    }
                    let pre = 0;
                    let cur = 0;
                    // 其实下面就是模拟splice的过程，利用双指针，一前一后逐个调整数组中元素的位置
                    while (cur < nums.length) {
                        if (nums[cur] !== val) {
                            // 也就是简单的复制，
                            nums[pre] = nums[cur];
                            pre++;
                        }
                        cur++; // 如果是对应的值，则忽视，指向下一个
        
                    }
                    nums = nums.slice(0, pre); // 因为pre已经++
                    return nums.length;
                };
                // let nums = [0, 1, 2, 2, 3, 0, 4, 2];
                // let val = 2;
                // console.log(removeElement(nums, val));
        
                // TODO: 28. 实现 strStr()
                // 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
                var strStr = function (haystack, needle) {
                    // return haystack.indexOf(needle)
                    if (needle === '') {
                        return 0;
                    }
                    for (let i = 0; i < haystack.length; i++) {
                        if (haystack[i] === needle[0]) {
                            let index = 0;
                            while (index < needle.length) {
                                if (haystack[i + index] === needle[index]) {
                                    index++;
                                    continue;
                                } else {
                                    break;
                                }
                            }
                            if (index === needle.length) {
                                return i;
                            }
                        }
                    }
                    return -1;
                };
                // let haystack = "hello";
                // let needle = "ll";
                // console.log(strStr(haystack, needle));
        
        
                // TODO: 30. 串联所有单词的子串
                // 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
                // 注意，words是长度相同的子串
                // s = "barfoothefoobarman", words = ["foo","bar"] 输出[0,9]，子串分别是 "barfoo" 和 "foobar" 。
                // 思路，使用滑动窗口的方法
                var findSubstring = function (s, words) {
                    if (s.length === 0 || words.length === 0) {
                        return [];
                    }
                    let re = [];
                    let window = new Array(words.length).fill(0); // 用来判断words中的使用情况
                    let words_len = words.length;
                    let substr_len = words[0].length;
                    let window_len = substr_len * words_len;
        
                    let map = new Map();
                    let obj = {};
                    for (let i = 0; i < words_len; i++) {
                        if (!!map.get(words[i])) {
                            let index = map.get(words[i]);
                            map.set(words[i], index + 1);
                        } else {
                            map.set(words[i], 1);
                            obj[words[i]] = 0;
                        }
                    }
                    // console.log(map);
                    // console.log(obj);
        
                    let left = 0;
                    let right = left + window_len - 1;
                    while (right < s.length) {
                        let flag = true;
                        for (let i = 0; i < words_len; i++) {
                            let start = left + i * substr_len;
                            let end = start + substr_len;
                            let str = s.slice(start, end);
                            // console.log(str);
                            if (!map.get(str) || obj[str] > map.get(str)) {
                                // 这里是找不到
                                flag = false;
                                break;
                            } else {
                                obj[str]++;
                            }
                        }
                        // console.log(obj);
                        if (flag) {
                            // console.log(s.slice(left, right + 1));
                            let flag2 = true;
                            for (let key in obj) {
                                if (obj[key] !== map.get(key)) {
                                    flag2 = false;
                                    break;
                                }
                            }
                            if (flag2) {
                                re.push(left);
                            }
                        }
                        // 哈希表置零
                        for (let key in obj) {
                            obj[key] = 0;
                        }
                        left++;
                        right++;
                    }
                    return re;
                };
                // let s = "wordgoodgoodgoodbestword";
                // let words = ["word", "good", "best", "good"];
                // console.log(findSubstring(s, words));
        
                // TODO: 31. 下一个排列
                // 也就是找出下一个比当前大的数字组合！！！如果当前数字组合是最大的话，那就找最小的
                // 思路，首先如果这个数字组合是降序，则就是最大数的组合！
                // 网上的一种解法，就是结尾处开始寻找第一个破坏升序的数，记录下标为pos，然后将pos+1之后的数进行升序排列。之后找出比pos下标的数大的数，与pos进行交换
                // 换言之，就是将后面的「大数」与前面的「小数」交换。但是将大数放在前面时候，也需要对剩余的数字进行升序排列，保证最小化！
                var nextPermutation = function (nums) {
                    if (!nums || nums.length === 0) {
                        return
                    }
                    let len = nums.length;
                    let pos = len - 1;
                    // 实际上是找前面的小数（注意，这个小数是破坏从尾到前升序的那个数）
                    while (pos > 0 && nums[pos] <= nums[pos - 1]) {
                        pos--;
                    }
                    if (pos === 0) {
                        // 证明是该数已经是最大值了！！！
                        return nums.reverse();
                    }
                    let rebuild = nums.slice(pos).reverse();
                    nums.splice(pos, rebuild.length, ...rebuild); // 学到了！！！splice(start,n,...arr);
                    // 此时，nums[pos-1]是破坏升序的那个数，也是所谓的小数，
                    // 找出排序好的数组中比nums[pos-1]大一点的数！
                    let big = pos;
                    while (nums[pos - 1] >= nums[big]) {
                        big++;
                    }
                    let temp = nums[pos - 1];
                    nums[pos - 1] = nums[big];
                    nums[big] = temp;
                    console.log(nums);
                    console.log(pos);
                    return nums;
                };
                // let nums = [2, 4, 3, 2, 1];
                // console.log(nextPermutation(nums));
        
                // TODO: 32. 最长有效括号
                // 输入: ")()())"  输出: 4  解释: 最长有效括号子串为 "()()"
                // 思路一，利用栈，注意，这里是把下标入栈。如果遇到')'出栈，这是用当前')'的下标减去出栈后栈顶的下标，自然就可以获得对应的长度！！
                // 栈顶表示一个子串的起始位置。只有全部出栈之后，才会重新初始化，重新定义起始位置
                var longestValidParentheses = function (s) {
                    if (!s || s.length === 0) {
                        return 0;
                    }
                    // 注意，因为要记录连续性！！！始终还是要先给栈多初始化一个-1！！！不能使栈有空的情况出现！！！
                    // 也就是，栈底保存初始位置的前一个！！！！！！
                    let stack = [-1];
                    let len = 0;
                    let re = 0;
                    for (let i = 0; i < s.length; i++) {
                        if (s[i] === '(') {
                            stack.push(i);
                        } else if (s[i] === ')') {
                            stack.pop();
                            if (stack.length === 0) {
                                // 栈底保存初始位置，证明前面都作废了，需重新初始化
                                stack.push(i);
                            } else {
                                // 长度是当前下标减去，出栈后的栈顶，栈的每一项其实代表当前的初始位置！！
                                len = i - stack[stack.length - 1];
                                if (len > re) {
                                    re = len;
                                }
                            }
                        }
                    }
                    return re;
                };
                // 思路二，动态规划
                // 也正是因为连续性的子串问题，可以使用一维数组记录最大的长度值
                // dp[i] 其中第 i个元素表示以下标为 i的字符结尾的最长有效子字符串的长度。初始化全部为0
                // 1."...()()()..."。在s[i-1]='('且s[i]=')'的时候，也就是产生了闭环，dp[i] = dp[i-2]+2; 
                // 2."...((()))..."。当出现s[i] = ')'且s[i-1] = ')'的时候，
                // 注意，dp[i-1]的意思是前一个中有效括号最长的长度！再-1是前一个。比如(())，就是指向第一个'('
                // 如果s[i-dp[i-1]-1] = '('。dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2。其中dp[i - dp[i - 1] - 2]是查看他上一个是不是也有值，比如'()(())'
                var longestValidParentheses2 = function (s) {
                    if (!s || s.length === 0) {
                        return 0;
                    }
                    let dp = new Array(s.length).fill(0);
                    let re = 0;
                    for (let i = 1; i < s.length; i++) {
                        if (s[i - 1] === '(' && s[i] === ')') {
                            dp[i] = i < 2 ? 2 : dp[i - 2] + 2;
                        } else if (s[i - 1] === ')' && s[i] === ')' && s[i - dp[i - 1] - 1] === '(') {
                            if (i - dp[i - 1] - 2 < 0) {
                                dp[i] = dp[i - 1] + 2;
                            } else {
                                dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;
                            }
                        }
                        re = Math.max(re, dp[i]);
                    }
                    return re;
                };
                // let s = "(()())";
                // console.log(longestValidParentheses2(s));
        
                // TODO: 33. 搜索旋转排序数组
                // nums = [4,5,6,7,0,1,2], target = 0  输出: 4
                // 时间复杂度必须是 O(log n) 级别。
                // 思路，必须是二分搜索！因为是反转的排序数组，也就是前面的数一定大于翻转到后面的数！！！！
                // 有个关键就是，肯定是一半有序一半无序的！
                // 以mid为分界线，如果nums[0]>nums[mid]，则证明左部分已经有翻转数组，已是无序！反而有部分是有序的！！！如果是小于则反之
                // 也就是先分哪边有序，然后去有序的地方找，有序地方没有就换边找
                var search = function (nums, target) {
                    if (!nums || nums.length === 0) {
                        return -1;
                    }
                    let l = 0;
                    let r = nums.length - 1;
                    while (l <= r) {
                        let mid = parseInt((l + r) / 2);
                        if (nums[mid] === target) {
                            return mid;
                        }
                        // 以下是正常的二分搜索
                        // if (nums[mid] === target) {
                        //     return mid;
                        // } else if (nums[mid] > target) {
                        //     r = mid - 1;
                        // } else {
                        //     l = mid + 1;
                        // }
                        // 翻转数组，有个特性就是一半有序一半无序！
                        // 前面的数一定大于翻转到后面的数！！！！
                        if (nums[0] < nums[mid]) {
                            // 左半部分有序
                            if (target >= nums[l] && target < nums[mid]) {
                                r = mid - 1;
                            } else {
                                // 再右方寻找
                                l = mid + 1;
                            }
                        } else {
                            // 右半部分有序
                            if (target >= nums[mid + 1] && target <= nums[r]) {
                                l = mid + 1;
                            } else {
                                r = mid - 1;
                            }
                        }
                    }
                    return -1;
                };
                // let nums = [3,4,5,1,2];
                // let target = 4;
                // console.log(search(nums, target));
        
                // TODO: 34. 在排序数组中查找元素的第一个和最后一个位置
                // nums = [5,7,7,8,8,10], target = 8 输出: [3,4]   如果不存在就输出[-1,-1]
                // 时间复杂度必须是 O(log n) 级别。
                // 利用两次二分法！！！！第一次二分法，指针往左，走到target的最左边；第二次二分法往右走，走到最右边
                // 关键点在于mid的取法！！！同时是下标0和1，向上取整则取1，向下取整则取0。
                var searchRange = function (nums, target) {
                    if (!nums || nums.length === 0) {
                        return [-1, -1];
                    }
                    let l = 0;
                    let r = nums.length - 1;
                    let re = [];
                    while (l < r) { // 致使l=r才结束
                        let mid = parseInt((l + r) / 2); // 向下取整，保证mid指向左边
                        if (target <= nums[mid]) {
                            r = mid; // 用右指针去靠近他
                        } else {
                            l = mid + 1;
                        }
                    }
                    if (nums[l] !== target) {
                        return [-1, -1];
                    }
                    re.push(l);
                    // l = 0; // 无需置空！！！因为最后一个值必定从当前的l往后的！
                    r = nums.length - 1;
                    while (l < r) { // 致使l=r才结束
                        let mid = Math.ceil((l + r) / 2); // 向上取整，保证mid指向右边
                        if (target >= nums[mid]) {
                            l = mid; // 用左指针去靠近
                        } else {
                            r = mid - 1;
                        }
                    }
                    re.push(l); // 最后l和r会重叠的！
                    return re;
                };
                // let nums = [5, 7, 7, 8, 8, 10];
                // console.log(searchRange(nums, 6));
        
                // TODO: 35. 搜索插入位置
                // 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
                // 因为有序，也是利用二分法！二分法最算最后找不到目标值，返回出来的l也是最接近目标的！ 要向右逼近！！！
                // 关于插入位置，必须使得l和r重叠后，继续走一遍，l才会是真正需要添加的位置！！！
                var searchInsert = function (nums, target) {
                    if (!nums && nums.length === 0) {
                        return 0;
                    }
                    let l = 0;
                    let r = nums.length - 1;
                    // 注意！！！！这里在l和r重叠的时候，需要继续往下，才能真正找出插入的位置！
                    while (l <= r) {
                        let mid = parseInt((l + r) / 2); // 向下取整
                        if (nums[mid] === target) {
                            // 因为数组中没有重复元素，如果找到相同元素，则直接在当前位置插入
                            return mid;
                        } else if (target > nums[mid]) {
                            l = mid + 1;
                        } else {
                            r = mid - 1;
                        }
                    }
                    // 如果target比nums[l]大，自然会l+1。如果target比nums[l]小，l不变，也自然是当前l位置！
                    return l;
                };
                // let nums = [1, 3, 5, 6];
                // console.log(searchInsert(nums, 2));
        
                // TODO: 38. 外观数列
                // 给一个数，这个数是1
                // 描述上一步的数，这个数是 1 即一个1，故写作11
                // 描述上一步的数，这个数是11即两个1，故写作21
                // 描述上一步的数，这个数是21即一个2一个1，故写作12-11
                // 描述上一步的数，这个数是1211即一个1一个2两个1，故写作11-12-21
                var countAndSay = function (n) {
                    let arr = new Array(n);
                    arr[0] = '1';
                    arr[1] = '11';
                    for (let i = 2; i < n; i++) {
                        let str = arr[i - 1] + '';
                        let temp = '';
        
                        let subStr = str[0];
                        let count = 1;
                        for (var j = 1; j < str.length; j++) {
                            if (subStr === str[j]) {
                                count++;
                            } else {
                                temp += `${count}${subStr}`
                                count = 1;
                            }
                            subStr = str[j];
                        }
                        temp += `${count}${str[j - 1]}`
                        arr[i] = temp;
                    }
                    return arr[n - 1];
                };
                // console.log(countAndSay(10));
        
                // TODO: 39. 组合总和
                // 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
                // candidates 中的数字可以无限制重复被选取。.
                // 输入: candidates = [2, 3, 5], target = 8, [[2, 2, 2, 2], [2, 3, 3], [3, 5]]
                // 思路，需要使用回溯法！！相当于一种全排列！
                var combinationSum = function (candidates, target) {
                    if (!candidates || candidates.length === 0) {
                        return [];
                    }
                    let result = [];
                    let path = [];
                    let residue = target;
                    let begin = 0; // 从下标0开始取
                    candidates.sort((a, b) => a - b); // 升序排序
                    _combinationSum(candidates, result, path, residue, begin);
                    return result;
                };
                // dfs，类似于二叉树一样。只不过这次是candidates.length叉树！
                // 比如当前剩余8，则接下来有2，3，5可以选择，选择不同的数就是不同的分支！
                // 在去重方面，举个例子，比如23xxx和32xxx是重复的，有个规律就是之前取过的数，之后就不允许再取了！！！
                // 以前会让arr.splice，之后再添加回去，但是这样比较麻烦！！直接用下标即可！
                function _combinationSum(candidates, result, path, residue, begin) {
                    if (residue === 0) {
                        // 这里有个巨坑！！！path如果是引用对象，则会报错！
                        result.push([...path]); // 需要当前拷贝，因为path是引用类型！！
                        return;
                    }
                    for (let i = begin; i < candidates.length; i++) {
                        if (residue - candidates[i] < 0) { // 注意，剪枝要放在最前面，否则影响回溯！！
                            break; // 当前不符合！直接退出循环回到上一层！
                        }
                        residue -= candidates[i]; // 状态转变，进入下一层递归，后续还需要回溯
                        path.push(candidates[i]);
                        // path += candidates[i];
                        _combinationSum(candidates, result, path, residue, i); // 下一个从下标i开始取，不允许取i之前的数，因为已经遍历过了！
                        // console.log(path);
                        // 注意！！！！回溯的时候，切莫用下面那个语句，相当于每次都创造一个新数组！！！而且也没有真正改变原数组！！！！！下一层递归的时候还是用原数组！
                        // 比如当前path = [1,1,1,1]，当时这句话后虽然path = [1,1,1]。但原来path[1,1,1,1]还是保留在递归当中！！！相当于每一次递归都生成一个新的数组！！！
                        // 下面这个语句除非是使用str类型，非引用类型就可以
                        // path = path.slice(0, path.length - 1); // 因为str在下一层递归中改变是不会影响之前层的！！
                        path.splice(path.length - 1, 1); // 回溯原本的状态，继续下一次循环
                        residue += candidates[i];
                    }
                }
                // let candidates = [2, 3, 5];
                // let target = 8;
                // console.log(combinationSum(candidates, target));
        
                // TODO: 40. 组合总和 II
                // candidates 中的每个数字在每个组合中只能使用一次。
                var combinationSum2 = function (candidates, target) {
                    if (!candidates || candidates.length === 0) {
                        return [];
                    }
                    // 先排序
                    candidates.sort((a, b) => a - b);
                    let result = [];
                    let path = [];
                    let residue = target;
                    let begin = 0; // 从最开始选取数字
                    _combinationSum2(candidates, begin, path, result, residue)
                    return result;
                };
                // 为了规避重复，也就是需要强有力的剪枝！！！还是利用下标begin来进行，也就是前面取到的数字，后面就不能再取了！
                // 利用begin的原理，比如[1,2,3,4],第一层为[1,2,3,4]中的1，其中可供选择的是[2,3,4]。第二层为[2,3,4]中的2，其中可供选择的是[3,4]。
                // 这样就可以避开重复了，而且也无需变动原数组中的candidates
                function _combinationSum2(candidates, begin, path, result, residue) {
                    // if (residue  < 0) {
                    //     return; // 注意，这里剪枝效果极其不好！！
                    // }
                    if (residue === 0) {
                        result.push([...path]);
                        return;
                    }
                    // let len = 
                    for (let i = begin; i < candidates.length; i++) {
                        let cur = candidates[i]
                        // 大剪枝
                        if (residue - cur < 0) {
                            // 直接在这里剪枝是最好的，不需要进入下一层递归再剪枝
                            break; // 之所以break，是因为candidates排序了！！！后面都是大数
                        }
                        // 小剪枝
                        // 注意，之所以出现重复，其实是因为有重复的数字，比如[1,1,1,5]target为6，则会有3个重复的！！
                        if (i > begin && candidates[i - 1] === candidates[i]) {
                            // 直接略过begin+1之后的重复数字（但是begin这个需要递归一次）
                            continue;
                        }
                        path.push(cur);
                        // candidates.splice(i, 1); // 注意！！！因为使用了begin下标，无需去动原数组了！！！！
                        _combinationSum2(candidates, i + 1, path, result, residue - cur); // 下一个从当前i+1开始
                        path.splice(path.length - 1, 1);
                        // candidates.splice(i, 0, cur); // 只需要回溯path，原数组已有begin进行迭代
                    }
                }
                // let candidates = [10, 1, 2, 7, 6, 1, 5];
                // let target = 8;
                // console.log(combinationSum2(candidates, target));
        */
        // TODO: 41. 缺失的第一个正数
        // 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
        // [3, 4, -1, 1]输出: 2，，，，[7,8,9,11,12]输出: 1
        // 不考虑负数和零和大于 n+1的数字，因为首次缺失的正数一定小于或等于 n + 1 。
        // 思路1，哈希表法！！！（但是空间复杂度不符合）
        var firstMissingPositive = function (nums) {
            let len = nums.length;
            let obj = {};
            for (let i = 0; i < len; i++) {
                if (!obj[nums[i]]) {
                    obj[nums[i]] = 1;
                } else {
                    obj[nums[i]]++;
                }
            }
            // 因为缺失的第一个正数一定是在[1,n+1]内！
            for (let i = 1; i <= len; i++) { // i=1从数字开始算
                if (!obj[i]) {
                    return i;
                }
            }
            return len + 1;
        };
        // 思路2，将数组视为哈希表
        // 就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位置，按照这种思路整理一遍数组。
        // 然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。
        var firstMissingPositive2 = function (nums) {
            let len = nums.length;
            for (let i = 0; i < nums.length; i++) {
                // 注意这里使用while，因为当前的位置换了另一个数字来，还需要继续调整
                // 直到i = nums[i]-1
                while (nums[i] <= len && nums[i] > 0 && nums[i] !== nums[nums[i] - 1]) {
                    // 例如：数值 3 应该放在索引 2 的位置上
                    // 下面的做法，只是将nums[i]调整到正确位置，但是交换过来的新数可能还是不满足nums[i]的位置
                    let temp = nums[nums[i] - 1];
                    nums[nums[i] - 1] = nums[i];
                    nums[i] = temp;
                }
            }
            console.log(nums);
            for (let i = 0; i < nums.length; i++) {
                if (nums[i] != i + 1) {
                    return i + 1;
                }
            }
            return len + 1;
        };
        // let nums = [3, 4, -1, 1];
        // // console.log(firstMissingPositive(nums));
        // console.log(firstMissingPositive2(nums));

        // TODO: 42. 接雨水
        // 类似于木桶装水
        // 利用双指针，左右之间以最小的那个指针进行移动！（木桶效应）当遇到大值的时候，则取大值！移动另一个指针
        // 在某个位置i处，它能存的水，取决于它左右两边的最大值中较小的一个的，和自身高度的差值。
        // 之所以要定义left_max和right_max是为了确定最多能装多少水，而left和right指针是为了确定当前位置能装的水量，并不能决定最多能装多少。。
        // 哪边小（_max）就移动哪边的指针！
        // 以两端往中间逼近
        var trap = function (height) {
            if (!height || height.length < 3) {
                return 0;
            }
            let left = 0;
            let right = height.length - 1;
            let left_max = 0; // 左边的最大值，它是从左往右遍历找到的
            let right_max = 0; // 右边的最大值，它是从右往左遍历找到的
            let re = 0;
            let curHeight = Math.min(height[left], height[right]);
            while (left <= right) { // 注意！两者相遇的时候，当前的位置也是需要计算的！！
                if (left_max < right_max) {
                    // 哪边小就移动哪边的指针
                    // 当前的装水量是取决于两端的！
                    re += Math.max(0, left_max - height[left]); // 防止为负数
                    left_max = Math.max(left_max, height[left]);
                    left++;
                } else {
                    re += Math.max(0, right_max - height[right]); // 防止为负数
                    right_max = Math.max(right_max, height[right]);
                    right++;
                }
            }
            return re;
        };

        // TODO: 415. 字符串相加
        // 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
        var addStrings = function (num1, num2) {
            // 为了防止num1和num2是Number类型，导致报错，所以一致变为字符串
            num1 = num1 + '';
            num2 = num2 + '';
            // 从尾到头相加
            let i = num1.length - 1;
            let j = num2.length - 1;
            let carry = 0; // 代表进位
            let re = '';
            while (i >= 0 || j >= 0) {
                let n1 = i >= 0 ? num1[i] - '0' : 0;
                let n2 = j >= 0 ? num2[j] - '0' : 0;
                let sum = n1 + n2 + carry;
                carry = sum >= 10 ? 1 : 0;
                re += sum % 10;
                i--; j--;
            }
            if (carry === 1) {
                re += 1;
            }
            return re.split("").reverse().join("");
        };

        // console.log("addStrings",addStrings("0","1"));


        // TODO: 43. 字符串相乘
        // 相当于模拟乘法，如num1 = "123", num2 = "456"，结果"56088"
        // 思路，普通竖式先乘然后补零再和结果相加（相加用之前写的相加方法，倒过来逆向相加）
        var multiply = function (num1, num2) {
            // 获取最短的数字作为乘数
            if (parseInt(num1) === 0 || parseInt(num2) === 0) {
                return "0"; // 注意，是返回字符串！！！
            }
            let re = '0';
            // 从末位开始相乘
            for (let i = num2.length - 1; i >= 0; i--) {
                // 注意！！！！必须模拟一位和多位的相乘！！！！
                // 以下模拟这个 carry = num2[i] * num1 + '';
                let carry = '';
                let n2 = num2[i] - '0';
                let temp = 0; // 代表进位
                for (let j = num1.length - 1; j >= 0 || temp !== 0; j--) {
                    let n1 = j >= 0 ? num1[j] : 0;
                    let sum = n1 * n2 + temp;
                    temp = sum >= 10 ? parseInt(sum / 10) : 0;
                    carry += sum % 10;
                }
                carry = carry.split("").reverse().join("");
                // 补零，补零的数量取决于len--1-i个(差值)
                for (let j = 0; j < num2.length - 1 - i; j++) {
                    carry += '0';
                }
                re = addStrings(re, carry);
            }
            return re;
        };
        // let num1 = "123";
        // let num2 = "456";
        // console.log(multiply(num1, num2));

        // console.log(mult('1234', '3'));

        // TODO: 45. 跳跃游戏 II
        // 给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。
        // 你的目标是使用最少的跳跃次数到达数组的最后一个位置
        // 思路一，贪婪算法，我们每次在可跳范围内选择可以使得跳的更远的位置。
        // 每次找局部最优，最后达到全局最优。很难有遇到贪心算法
        // 正向查找可到达的最大位置
        // 时间复杂度：O(n)，其中 n是数组长度
        var jump = function (nums) {
            if (!nums || nums.length === 0) {
                return 0;
            }
            let i = 0;
            let step = 0;
            let max = 0; // 贪心算法，获取局部最优。最远能跳到的位置
            while (i < nums.length - 1) {
                let n = nums[i];
                if (i + n >= nums.length - 1) {
                    // 如果当前就可以跳出，就无需继续寻找。
                    return step + 1;
                }
                let next = i + 1; // 下一个要跳的位置
                // 注意，这里的局部最优指的是当前可跳的长度+另一个可跳的长度。
                // 也就是局部中，下一个位置最远处！如[10,9,8,7,6,5,4,3,2,1,1,0]，一定是跳10个单位，再跳1个单位！
                for (let j = i + 1; j <= i + n; j++) {
                    if (max < j + nums[j]) {
                        max = j + nums[j];
                        next = j;
                    }
                }
                i = next;
                step++;
            }
            return step;
        };
        // // let nums = [1, 2, 1, 1, 1];
        // let nums = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1, 0];
        // console.log(jump(nums));

        // 思路二，我们知道最终要到达最后一个位置，然后我们找前一个位置，遍历数组，找到能到达它的位置，离它最远的就是要找的位置。然后继续找上上个位置，最后到了第 0 个位置就结束了。
        // 反向查找出发位置
        // 时间复杂度：O(n^2)
        var jump2 = function (nums) {
            let pos = nums.length - 1; // 从尾部开始找
            let step = 0;
            // 等于0代表找到初始位置
            while (pos > 0) {
                // 在前面所有数字中（除pos以外）寻找入口
                for (let i = 0; i < pos; i++) {
                    if (nums[i] + i >= pos) {
                        // 证明当前这个可以跳到尾端。
                        // 注意，如果是从尾端找起，越靠前的跳跃就优先取到！无需继续往后找
                        pos = i;
                        step++;
                        break; // 跳出当前循环，继续找以当前为结束的前面跳跃点
                    }
                }
            }
            return step;
        };

        // TODO: 46. 全排列
        // 给定一个 没有重复 数字的序列，返回其所有可能的全排列。
        // 这个之前就走过很多了，用dfs算法，利用剪枝避免重复
        // 这个和之前的组合总和不一样！组合中是半排列，[1,2,3]和[3,2,1]是重复项。
        // 全排列有先后顺序之别
        var permute = function (nums) {
            if (nums <= 0) {
                return [];
            }
            let res = [];
            let path = [];
            _permute(nums, res, path);
            return res;
        };
        function _permute(nums, res, path) {
            if (nums.length === 0) {
                res.push([...path]);
                return;
            }
            let len = nums.length;
            // 如果是半排列，可以用begin来限制重选问题
            // 组合的话，是需要避免重复的，也就是选择了之后就不得选择了
            for (let i = 0; i < len; i++) {
                let n = nums[i];
                path.push(n);
                nums.splice(i, 1);
                _permute(nums, res, path);
                path.splice(path.length - 1, 1);
                nums.splice(i, 0, n);
            }
        }
        // let nums = [1, 2, 3];
        // console.log(permute(nums));

        // TODO: 47. 全排列 II
        // 这里给的nums是含有重复数字的！！！
        // 只是多一个去重过程
        var permuteUnique = function (nums) {
            if (nums <= 0) {
                return [];
            }
            // 需要先排序，这样方便去重！！！！
            nums.sort((a, b) => a - b);
            let res = [];
            let path = [];
            _permuteUnique(nums, res, path);
            return res;
        };
        function _permuteUnique(nums, res, path) {
            if (nums.length === 0) {
                res.push([...path]);
                return;
            }
            let len = nums.length;
            // 如果是半排列，可以用begin来限制重选问题
            // 组合的话，是需要避免重复的，也就是选择了之后就不得选择了
            for (let i = 0; i < len; i++) {
                if (i > 0 && nums[i] === nums[i - 1]) {
                    continue;
                }
                let n = nums[i];
                path.push(n);
                nums.splice(i, 1);
                _permuteUnique(nums, res, path);
                path.splice(path.length - 1, 1);
                nums.splice(i, 0, n);
            }
        }
        // let nums = [3,3,0,3];
        // console.log(permuteUnique(nums));

        // TODO: 48. 旋转图像
        // 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。
        // [
        //     [1, 2, 3],
        //     [4, 5, 6],
        //     [7, 8, 9]
        // ]
        // [
        //     [7, 4, 1],
        //     [8, 5, 2],
        //     [9, 6, 3]
        // ]
        // 思路，转置加翻转
        var rotate = function (matrix) {
            let row = matrix.length;
            let col = matrix[0].length;
            // 转置就是a[i][j]变成a[j][i]。并且列数和行数交换
            for (let j = 0; j < col; j++) {
                for (let i = j; i < row; i++) {
                    // 不是全部都换，全部都换则变回原来的。
                    // 只换一个三角的！！！
                    let temp = matrix[i][j];
                    matrix[i][j] = matrix[j][i];
                    matrix[j][i] = temp;
                }
            }
            // 现在行变列，列变行，可能会有多出来为undifined的
            // 需要去掉
            matrix.splice(row - 1, row - col); // 
            for (let i = 0; i < col; i++) {
                matrix[i].reverse();
            }
            return matrix;
        };
        // let matrix = [
        //     [1, 2, 3],
        //     [4, 5, 6],
        //     [7, 8, 9]
        // ];
        // let matrix = [
        //     [1, 2],
        //     [3, 4],
        //     [5, 6]
        // ];
        // console.log(rotate(matrix));

        // TODO: 49. 字母异位词分组
        // 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
        // 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
        // 输出:
        // [
        //     ["ate", "eat", "tea"],
        //     ["nat", "tan"],
        //     ["bat"]
        // ]
        var groupAnagrams = function (strs) {

        };

        // TODO: 50. Pow(x, n)
        // 低效的做法！！
        var myPow2 = function (x, n) {
            let re = 1;
            for (let i = 0; i < Math.abs(n); i++) {
                re *= x;
            }
            if (n < 0) {
                re = 1 / re;
            }
            return re;
        };
        // 思路二，快速幂 + 递归
        // 「快速幂算法」的本质是分治算法。
        // x->(x^2)->(x^4)->(x^8)->(x^16)   也就是如果要求(x^16)只需要求得(x^16)即可，
        // 因为(x^n)^2 = x^(n*2);
        // 递归思路，是从结果细分到子问题。要求x^n，也就是求y = x^(n/2)
        // 递归中，如果n为偶数，则x^n=y^2，如果n为奇数，则x^n=y^2*x;
        // 递归的边界，任何数零次方为1
        // 因为分治，时间复杂度为O(logn)
        var myPow = function (x, n) {
            let flag = n > 0 ? true : false; // 表示是否为正数
            let re = _myPow(x, Math.abs(n));
            re = flag ? re : 1 / re;
            return re;
        };
        function _myPow(x, n) {
            if (n === 0) {
                return 1;
            }
            if (n % 2 === 0) {
                // 偶数
                let y = _myPow(x, parseInt(n / 2)); // 向下取整
                return y * y;
            } else {
                let y = _myPow(x, parseInt(n / 2));
                return y * y * x;
            }
        }

        // let x = 2.00000;
        // let n = -2;
        // console.log(myPow(x, n));

        // TODO: 关于异步
        // console.log(1);
        // setTimeout(()=>{
        //     // 异步任务会挂起，先执行同步任务
        //     console.log(2); // 这个最最最后才执行！
        // },0)
        // console.log("~~~~");
        // let p = new Promise((resolve,reject)=>{
        //     // 在Promise新建后会立即执行，所以首先输出 AAA（相当于同步任务一样）
        //     console.log(3);
        //     resolve();
        // }).then(()=>{
        //     // 然后，then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行。
        //     console.log(4);
        // })
        // console.log('end'); 

        // TODO: 55. 跳跃游戏
        // 跳跃游戏2是寻找最少跳跃次数，这个是查找是否可以跳到结束
        // 一样可以延用跳跃游戏2的贪心算法
        // 其重点在于，不是贪心跳到最远那个位置，而是去到能跳最远的那个位置上，继续寻找
        // [2,3,1,1,4] 输出: true   [3,2,1,0,4]   输出: false
        var canJump = function (nums) {
            let pos = 0;
            let len = nums.length;
            while (pos < len - 1) {
                let n = nums[pos];
                let temp = pos + n;
                let index = pos + n; // 初始化按当前跳跃最远的位置
                for (let i = pos + 1; i <= pos + n; i++) {
                    if (nums[i] + i >= temp) {
                        // 寻找靠后的！
                        temp = nums[i] + i;
                        index = i; // 先去到能跳最远位置的地方再次寻找
                    }
                }
                if (pos === index) {
                    // 证明没有进展
                    return false;
                } else {
                    pos = index;
                }
            }
            return true;
        };
        // let nums = [5, 9, 3, 2, 1, 0, 2, 3, 3, 1, 0, 0];
        // console.log(canJump(nums));

        // TODO: 56. 合并区间
        // 给出一个区间的集合，请合并所有重叠的区间。
        // 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]]
        // 思路，区间的合并，首先要做的是排序！！！！！以每个区间的左端点排序。然后利用左右指针进行合并区间
        // 因为可以合并的区间一定是连续的！！！
        var merge = function (intervals) {
            if (!intervals || intervals.length === 0) {
                // 必不可少的一步
                return [];
            }
            intervals.sort((a, b) => {
                // 从小到大排序
                return a[0] - b[0];
            })
            let re = [];
            let left = intervals[0][0];
            let right = intervals[0][1];
            for (let i = 1; i < intervals.length; i++) {
                let newLeft = intervals[i][0];
                let newRight = intervals[i][1];
                if (newLeft <= right) {
                    // 先不断更新右指针，直到不能更新的时候，就把当前的区间添加到结果中
                    right = Math.max(right, newRight);
                } else {
                    // 在无法合并的时候，才去添加
                    re.push([left, right]);
                    // 需要更新左右指针
                    left = newLeft;
                    right = newRight;
                }
            }
            // 因为下一次的没法更新，还缺最后一组
            re.push([left, right]);
            return re;
        };
        let intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];
        // let intervals = [[1, 4], [4, 5]];
        console.log(merge(intervals));
    </script>
</body>

</html>