<!--
 * @Autor: hjz
 * @Date: 2020-05-13 12:01:57
 * @LastEditors: hjz
 * @LastEditTime: 2020-05-25 17:44:41
 * @Description: 剑指offer
 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // TODO: 1.二维数组中的查找
        // 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
        // 思路，因为递增关系，只要a[0][i]>target就不需要遍历该列了！
        function Find(target, array) {
            // 参数array是一个二维数组
            let row_len = array.length;
            let col_len = array[0].length;
            let jIndex = col_len - 1;
            for (let i = 0; i < row_len; i++) {
                for (let j = jIndex; j >= 0; j--) {
                    if (array[i][j] > target) {
                        // 剪枝，直接排除当前和右边的列
                        jIndex--;
                    }
                    if (array[i][j] === target) {
                        return true;
                    }
                }
            }
            return false;
        }
        // console.log(Find(2,[[1,3,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]));

        // TODO: 2.替换空格
        // 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
        // 方法一，普通做法
        function replaceSpace(str) {
            let newStr = str.split("").map((item) => {
                if (item === " ") {
                    return "%20";
                } else {
                    return item;
                }
            })
            return newStr.join("");
        }
        // 方法二，正则表达式
        function replaceSpace(str) {
            return str.replace(/ /g, '%20');
        }
        // console.log(replaceSpace('hello world'));

        // TODO: 3.从尾到头打印链表
        // 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
        // 思路。因为最后是返回一个Array，所以只需要遍历一遍链表再reverse()即可
        function ListNode(x) {
            this.val = x;
            this.next = null;
        }
        function LinkList() {
            // this.head = new ListNode(null);
            this.head = null;
            this.add = function (v) {
                let node = new ListNode(v);
                node.next = this.head;
                this.head = node;
            }
        }
        // let list = new LinkList();
        // list.add(1);
        // list.add(2);
        // list.add(3);
        // list.add(4);
        function printListFromTailToHead(head) {
            // write code here
            if (!head) {
                return 0;
            }
            let re = new Array();
            let curNode = head;
            while (curNode) {
                re.push(curNode.val);
                curNode = curNode.next;
            }
            return re.reverse();
        }
        // console.log(printListFromTailToHead(list.head));

        // TODO: 4.重建二叉树
        // 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
        function TreeNode(v) {
            this.val = v;
            this.left = null;
            this.right = null;
        }
        function Tree() {
            this.root = null;
            this.add = function (v) {
                this.root = this._add(this.root, v);
            }
            this._add = function (node, v) {
                if (node === null) {
                    return new TreeNode(v);
                }
                if (v > node.val) {
                    node.right = this._add(node.right, v);
                } else {
                    node.left = this._add(node.left, v);
                }
                return node;
            }
            // 先序遍历
            this.preTransverse = function () {
                let arr = [];
                this._preTransverse(this.root, arr);
                // console.log("arr", arr);
                return arr;
            }
            this._preTransverse = function (node, arr) {
                if (node === null) {
                    return;
                }
                // console.log(node);
                arr.push(node.val);
                this._preTransverse(node.left, arr);
                this._preTransverse(node.right, arr);
            }
            // 中序遍历
            this.inTransverse = function () {
                let arr = [];
                this._inTransverse(this.root, arr);
                console.log("arr", arr);
                return arr;
            }
            this._inTransverse = function (node, arr) {
                if (node === null) {
                    return;
                }
                this._inTransverse(node.left, arr);
                // console.log(node);
                arr.push(node.val);
                this._inTransverse(node.right, arr);
            }
        }
        // let tree = new Tree();
        // tree.add(4);
        // tree.add(2);
        // tree.add(5);
        // tree.add(1);
        // tree.add(3);
        // tree.add(6);
        // let pre = tree.preTransverse();
        // let vin = tree.inTransverse();
        // console.log(tree);
        // 参数pre和vin指的是先序遍历和中序遍历的输出数组
        // 重构树，可以使用递归！！！！先序可以确定父节点，而中序根据父节点来分左右子树。然后进行递归
        // 同时，中序分了左右子树，也可以在先序中的parentIndex+1位置，分出左右子树
        function reConstructBinaryTree(pre, vin) {
            if (pre.length < 1 || vin.length < 1) {
                // 注意边界值
                return null;
            }
            let parent = new TreeNode(pre[0]);
            let parentIndex = vin.indexOf(pre[0]);
            let left = vin.slice(0, parentIndex);
            let right = vin.slice(parentIndex + 1);
            parent.left = reConstructBinaryTree(pre.slice(1, parentIndex + 1), left);
            parent.right = reConstructBinaryTree(pre.slice(parentIndex + 1), right);
            return parent;
        }
        // console.log(reConstructBinaryTree(pre, vin));

        // TODO: 5.用两个栈实现队列
        // 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
        // 思路，利用栈2作为出队的栈，每次pop，就将栈1压到栈2pop，然后再重新倒回去栈1
        function Stack5() {
            let stack1 = [];
            let stack2 = [];
            function push(node) {
                // 第一个栈专门入栈
                stack1.push(node);
            }
            function pop() {
                if (stack1.length === 0) {
                    return;
                }
                // 先将栈1内容压到栈2
                let temp = stack1.pop();
                while (temp !== undefined) {
                    stack2.push(temp);
                    temp = stack1.pop(); // 继续出栈！！！
                }
                // 栈2的栈顶就是出队的元素
                let re = stack2.pop();
                // 最后再把栈2中的内容重新压回栈1
                temp = stack2.pop();
                while (temp !== undefined) {
                    stack1.push(temp);
                    temp = stack2.pop(); // 继续出栈！！！
                }
                return re;
            }
            push(1);
            push(2);
            push(3);
            push(4);
            console.log(pop());
            console.log(pop());
            console.log(pop());
            console.log(pop());
        }
        // Stack5();

        // TODO: 6.旋转数组的最小数字
        // 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
        // {3,4,5,1,2}思路即是，找出不递增的数字，就输出
        function minNumberInRotateArray(rotateArray) {
            // write code here
            let len = rotateArray.length;
            if (len === 0) {
                return 0;
            }
            let pre = rotateArray[0];
            for (let i = 1; i < len; i++) {
                if (rotateArray[i] < pre) {
                    return rotateArray[i];
                }
            }
        }
        // console.log(minNumberInRotateArray([3,4,5,1,2]));

        // TODO: 7.斐波那契数列
        function Fibonacci(n) {
            let f = [0, 1];
            for (let i = 2; i <= n; i++) {
                f[i] = f[i - 1] + f[i - 2];
            }
            return f[n];
        }

        // TODO: 8.跳台阶
        // 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
        // 思路，使用动态规划。只需用一个一维数组，其中f[i]代表，到当前n级阶级最多的跳法。
        // 其方程式是斐波那契数列，因为青蛙要跳n级台阶，必须先跳到n-1级和n-2级台阶。
        // 其问的是跳法！！！不需要所谓的max+1。n-1跳一步，n-2跳两步，他们本身是没有产生+1的，只是前面的基础上多跳一步而已，也就是跳法不变。其中n-1和n-2的跳法都符合跳n台阶的跳法，所以两者相加
        // 注意！！！f(1) = 1，f(2) = 2。这个和斐波那契不一样
        function jumpFloor(number) {
            let f = [0, 1, 2];
            for (let i = 3; i <= number; i++) {
                f[i] = f[i - 1] + f[i - 2];
            }
            return f[number];
        }
        // console.log(jumpFloor(4));

        // TODO: 9.变态跳台阶
        // 这是普通跳台阶的拓展，同样道理，f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(0)
        // 其中因为 f(n-1) = f(n-2) + f(n-3) + ... + f(0)，所以f(n) = f(n-1) + f(n-1);
        // 注意，这里设定f(0) = 1;  但实际上f[0] = 0; f[1] = 1;不影响f(n-1)*2的
        function jumpFloorII(number) {
            let f = [0, 1];
            for (let i = 2; i <= number; i++) {
                f[i] = 2 * f[i - 1];
            }
            return f[number];
        }

        // TODO: 10.矩阵覆盖
        // 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
        // 其中的思路是，因为有竖着或横着两种方法。原来f(n-1)的基础上右边加一个竖条，在f(n-2)的基础上右边加两个横条
        // 也就是f(n)是由f(n-1)和f(n-2)转变而来。所有其类型和跳台阶问题类似。
        function rectCover(number) {
            let f = [0, 1, 2];
            for (let i = 3; i <= number; i++) {
                f[i] = f[i - 1] + f[i - 2];
            }
            return f[number];
        }

        // TODO: 11.二进制中1的个数
        // js中，十进制转二进制：toString(进制数)  二进制转十进制：parseInt("n进制数",n)
        function NumberOf1(n) {
            if (n < 0) {
                n = n >>> 0;
            }
            let arr = n.toString(2).split("");
            let re = 0;
            arr.forEach((item) => {
                if (item === '1') {
                    re++;
                }
            })
            return re;
        }

        // TODO: 12.数值的整数次方
        // 这里有个坑！！！！就是exponent可以是负数
        function Power(base, exponent) {
            let re = 1;
            let n = Math.abs(exponent);
            for (let i = 0; i < n; i++) {
                re *= base;
            }
            if (exponent < 0) {
                return 1 / re;
            }
            return re;
        }
        // 方法二，pow(x,y)返回 x 的 y 次幂。
        function Power(base, exponent) {
            return Math.pow(base, exponent);
        }

        // TODO: 13.调整数组顺序使奇数位于偶数前面
        // 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
        // 其中的奇数和奇数，偶数和偶数之间的相对位置不变。意思是假设以奇数作为参考，就相当于把偶数都抽离出去，那么剩下的所有奇数保持之前的先后顺序。
        function reOrderArray(array) {
            let even = [];
            let odd = [];
            // 注意，判断奇偶可以利用与&运算符x & 1 === 0为偶数。
            array.forEach((item) => {
                if ((item & 1) === 0) {
                    // 注意！！！！！！必须加上括号才行！！！
                    even.push(item);
                } else {
                    odd.push(item);
                }
            })
            return odd.concat(even);
        }
        // let array = [1, 2, 3, 4, 5, 6, 7];
        // console.log(reOrderArray(array));

        // TODO: 14.链表中倒数第k个节点
        // 思路，假设有n个节点，倒数第k个节点就是从头结点开始的第n-k+1个节点
        function FindKthToTail(head, k) {
            if (head === null || k <= 0) {
                return null;
            }
            let curNode = head;
            let n = 0;
            while (curNode !== null) {
                curNode = curNode.next;
                n++;
            }
            curNode = head;
            // 注意，有可能会越界！！！！k大于链表长度
            if (k > n) {
                return null;
            }
            for (let i = 0; i < n - k; i++) {
                // 遍历n-k次
                curNode = curNode.next;
            }
            return curNode;
        }
        // 方法二，快慢指针，快指针先走k-1步，之后快慢指针同步走，走到快指针走到最后一个结点的时候，慢指针也走到了倒数第k个结点
        function FindKthToTail2(head, k) {
            if (head === null || k <= 0) {
                return null; // 返回一个空对象
            }
            let curNode = head;
            while (k > 1) {
                curNode = curNode.next;
                k--;
            }
            if (curNode === null) {
                return null;
            } else {
                let k_node = head;
                curNode = curNode.next; // 需要提前一个
                while (curNode !== null) {
                    curNode = curNode.next;
                    k_node = k_node.next;
                }
                return k_node;
            }
        }

        // let list = new LinkList();
        // list.add(1);
        // list.add(2);
        // list.add(3);
        // list.add(4);
        // console.log(FindKthToTail(list.head,2));

        // TODO: 15.反转链表
        // 思路，用数组保存链表节点的值下来，然后再用数组的reverse方法，最后再重构链表
        // 更好的方法，就是反转后的头结点变成尾节点，不断遍历，然后头部插入有倒序效果，这样就可以反转了
        // 注意！！！这个反转链表，真的务必注意先后顺序！！！
        function ReverseList(pHead) {
            if (pHead === null) {
                return null;
            }
            let newHead = pHead;
            let curNode = pHead.next; // 直接从下一个开始选择，然后往前移动
            newHead.next = null; // 反转后的头结点变成尾节点
            while (curNode !== null) {
                let temp = curNode.next; // 保存下一个
                curNode.next = newHead;
                newHead = curNode;
                curNode = temp; // 继续迭代下一个
            }
            return newHead;
        }
        // let list = new LinkList();
        // list.add(1);
        // list.add(2);
        // list.add(3);
        // list.add(4);
        // console.log(ReverseList(list.head));

        // TODO: 16.合并两个排序的链表
        function Merge(pHead1, pHead2) {
            // write code here
            if (pHead1 === null) {
                return pHead2 === null ? null : pHead2;
            } else if (pHead2 === null) {
                return pHead1;
            }
            let curNode1 = pHead1;
            let curNode2 = pHead2;
            let nullNode = new ListNode(-1); // 创建一个虚拟头部，之后再替换！！！
            nullNode.next = null;
            let newHead = nullNode;
            let tail = newHead; // 合并的新链表，采用尾插法，需要借助tail，指向倒数第一个
            while (curNode1 !== null && curNode2 !== null) {
                if (curNode1.val <= curNode2.val) {
                    let node = new ListNode(curNode1.val);
                    node.next = tail.next;
                    tail.next = node;
                    tail = node; // tail指向倒数第一个节点
                    curNode1 = curNode1.next;
                } else {
                    let node = new ListNode(curNode2.val);
                    node.next = tail.next;
                    tail.next = node;
                    tail = node; // tail指向倒数第一个节点
                    curNode2 = curNode2.next;
                }
            }
            if (curNode1 === null) {
                while (curNode2 !== null) {
                    let node = new ListNode(curNode2.val);
                    node.next = tail.next;
                    tail.next = node;
                    curNode2 = curNode2.next;
                    tail = node;
                }
            } else {
                while (curNode1 !== null) {
                    let node = new ListNode(curNode1.val);
                    node.next = tail.next;
                    tail.next = node;
                    curNode1 = curNode1.next;
                    tail = node;
                }
            }
            newHead = newHead.next;
            return newHead;
        }
        // 以下这个是会改变原链表的
        function Merge2(pHead1, pHead2) {
            // write code here
            if (pHead1 === null) {
                return pHead2 === null ? null : pHead2;
            } else if (pHead2 === null) {
                return pHead1;
            }
            let curNode1 = pHead1;
            let curNode2 = pHead2;
            let newHead = new ListNode(-1); // 创建一个虚拟头部，之后再替换！！！
            let tail = newHead; // 指向新链表的尾部
            while (curNode1 !== null && curNode2 !== null) {
                if (curNode1.val <= curNode2.val) {
                    tail.next = curNode1;
                    curNode1 = curNode1.next;
                } else {
                    tail.next = curNode2;
                    curNode2 = curNode2.next;
                }
                tail = tail.next; // 保证指向尾部
            }
            if (curNode1 !== null) {
                tail.next = curNode1;
            } else {
                tail.next = curNode2;
            }
            newHead = newHead.next;
            // 回收指针，注意，回收指针只需要让他们指向null即可！
            curNode1 = curNode2 = tail = null;
            return newHead;
        }
        // let list1 = new LinkList();
        // list1.add(7);
        // list1.add(5);
        // list1.add(3);
        // list1.add(1);
        // let list2 = new LinkList();
        // list2.add(10);
        // list2.add(8);
        // list2.add(4);
        // list2.add(2);
        // console.log(Merge2(list1.head, list2.head));

        // TODO: 17.树的子结构
        // 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
        // 查找A中是否存在树B结构一样的子树，可以分为两步：
        // 第一步，在树Ａ中找到和树Ｂ的根节点的值一样的节点Ｒ
        // 第二步，判断Ａ中以Ｒ为根节点的子树是不是包含和树Ｂ一样的结构
        function HasSubtree(pRoot1, pRoot2) {
            // 注意！！！外层的函数作用是遍历整颗树，然后每个节点（左右子树和根）进行比对是否存在相同结构
            // 空树不是任意一个树的子结构     
            if (pRoot1 === null || pRoot2 === null) {
                // 首先保证pRoot2不能为空
                return false;
            }
            // 和树的先序遍历一样，先根结点，然后左右子树比对
            if (isSubTree(pRoot1, pRoot2)) {
                return true;
            } else {
                return isSubTree(pRoot1.left, pRoot2) || isSubTree(pRoot1.right, pRoot2)
            }

            // 内部函数，内部调用
            // 此时，pRoot1和pRoot2是拥有相同的父节点
            // 接着判断Ａ中以Ｒ为根节点的子树是不是包含和树Ｂ一样的结构
            function isSubTree(pRoot1, pRoot2) {
                // 这个函数作用是判断两个树结构是否是子父关系
                if (pRoot2 === null) {
                    // 其中会涉及子树问题！！！而最外层已经做了pRoot2 === null的限制
                    // 因为pRoot1>=pRoot2如果树B遍历完，则证明树B全都对上了
                    // 换句话说，在递归中，默认空节点是符合子树概念的
                    // 因为递归结构，此为递归结束条件。
                    return true;
                }
                if (pRoot1 === null) {
                    // 此时是树B未遍历完，而树A已经遍历完，证明树B多于树A，对不上
                    return false;
                }
                // 一样和树的先序遍历一样，先根然后左右子树比对
                if (pRoot1.val === pRoot2.val) {
                    // 因为是判断相同的子树结构，所以需要&&
                    return isSubTree(pRoot1.left, pRoot2.left) && isSubTree(pRoot1.right, pRoot2.right);
                } else {
                    return false;
                }
            }
        }


        // TODO: 18.二叉树的镜像
        // 操作给定的二叉树，将其变换为源二叉树的镜像。
        // 也就是所有的左右子树调换位置
        // 思路是递归，和先序遍历二叉树一样。注意，其中是概念原树的！！！
        function Mirror(root) {
            if (root === null) {
                return null;
            }
            let temp = root.left;
            root.left = root.right;
            root.right = temp;
            // 可以不用判断root.left和root.right，因为进入下一层递归会有判断
            Mirror(root.left);
            Mirror(root.right);
        }

        // TODO: 19.顺时针打印矩阵
        // 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字
        // 这道题的思路，在于判断是否到达边界！！！打印一圈分为4步，用四个while循环并且附带结束条件。
        function printMatrix(matrix) {
            // js中的二维数组的表示是，[[],[],[]....]
            if (!matrix || matrix.length < 1) {
                return null;
            }
            let row_len = matrix.length;
            let col_len = matrix[0].length;
            let len = row_len * col_len;
            let circle = 0; // 代表圈数
            let i = 0;
            let j = 0;
            let result = [];
            while (1) {
                // 先从左到右，到达最右边则结束
                while (j < col_len - circle) {
                    result.push(matrix[i][j]);
                    j++;
                }
                if (result.length === len) break; // 结束条件
                j--; // 因为while循环结束时j++越界了。
                i++; // 从下一个继续。
                // 从上到下，到达底部结束
                while (i < row_len - circle) {
                    result.push(matrix[i][j]);
                    i++;
                }
                if (result.length === len) break; // 结束条件
                i--;
                j--;
                // 从右到左，到达最左边结束
                while (j >= circle) {
                    result.push(matrix[i][j]);
                    j--;
                }
                if (result.length === len) break; // 结束条件
                j++;
                i--;
                circle++; // 注意！！！下一次从下到上，已经受到第一次影响了，所以圈数提前+1
                // 从下到上，到达最上面结束
                while (i >= circle) {
                    result.push(matrix[i][j]);
                    i--;
                }
                if (result.length === len) break; // 结束条件
                i++;
                j++;
            }
            return result;
        }

        // TODO: 20.包含min函数的栈
        // 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
        // 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。
        function Stack20() { // 可以理解外层套一个类，类里面有自己的数据和方法！
            // 把内容放入
            let stack = []; // 对于这种题，虽说是让我们实现方法，但是前提还是需要先定义一个栈！！！
            let minStack = []; // 思路，用空间换时间，多定义一个和原栈相对应的栈，用于保存最小值。
            function push(node) {
                if (node <= minStack[minStack.length - 1] || minStack.length === 0) {
                    // 注意，就算和min的栈顶相同也要入栈，这样保证出栈一致性
                    minStack.push(node);
                }
                stack.push(node);
            }
            function pop() {
                let node = stack.pop();
                if (node === minStack[minStack.length - 1]) {
                    minStack.pop();
                }
                return node; // 如果是空数组，也就返回undifined
            }
            function top1() {
                return stack[stack.length - 1];
            }
            function min() {
                // 时间复杂度应为O（1）
                return minStack[minStack.length - 1];
            }
            push(1);
            push(2);
            push(1);
            push(1);
            console.log(stack);
            console.log(minStack);
        }
        // Stack20();

        // TODO: 21.栈的压入、弹出序列
        // 序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列
        // 思路即是模拟栈的压入和弹出！！！
        function IsPopOrder(pushV, popV) {
            let j = 0;
            let stack = [];
            for (let i = 0; i < pushV.length; i++) {
                // 边入栈，边出栈！
                stack.push(pushV[i]);
                while (stack.length > 0 && stack[stack.length - 1] === popV[j]) {
                    j++;
                    stack.pop();
                }
            }
            // 因为两个序列的长度是相等的，如果符合则全部出栈
            return stack.length === 0;
        }

        // TODO: 22.从上往下打印二叉树
        // 其实就是层次遍历（广度优先遍历breadth first traversal）二叉树，用队列。
        // 过程是父节点出队，然后左右子树入队。结束条件是全部出队
        function PrintFromTopToBottom(root) {
            if (root === null) {
                return [];
            }
            let queue = [];
            let result = [];
            queue.push(root);
            while (queue.length > 0) {
                let node = queue.shift();
                result.push(node.val);
                if (node.left !== null) {
                    queue.push(node.left);
                }
                if (node.right !== null) {
                    queue.push(node.right);
                }
            }
            console.log(result);
            return result;
        }
        // let tree = new Tree();
        // tree.add(4);
        // tree.add(2);
        // tree.add(5);
        // tree.add(1);
        // tree.add(3);
        // tree.add(6);
        // console.log(tree.root);
        // PrintFromTopToBottom(tree.root);

        // TODO: 23.二叉搜索树的后序遍历序列
        // 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
        // 后序遍历的规则是左右子树再到根。
        // 注意：测试用例用的是 false/true, 不是题目中的 'Yes'/'No'
        // 思路，需要用到一个递归。数组的末位是根结点，然后根据根结点分左右子树，分边后判断右子树有没有大于根结点的
        function VerifySquenceOfBST(sequence) {
            // write code here
            if (sequence.length <= 0) {
                return false;
            }
            return adjustSequence(0, sequence.length - 1);
            // 利用递归，先中后序遍历的结果都可以用递归倒带。
            function adjustSequence(start, end) {
                // 参数是数组的首尾下标
                // 递归结束条件，开始和结尾相同，代表最后递归到只剩一个元素，则返回真
                if (start >= end) {
                    return true;
                }
                let root = sequence[end];
                // 根据root进行分边！！！！
                for (var i = start; i < end && sequence[i] < root; i++);
                // 注意，这里的i需要被外部调用，所有用var
                let rightIndex = i; // 分边，此时为右子树的初始
                for (var i = rightIndex + 1; i < end; i++) {
                    if (sequence[i] < root) {
                        return false;
                    }
                }
                return adjustSequence(start, rightIndex - 1) && adjustSequence(rightIndex, end - 1);
            }
        }
        // let sequence = [2,5,4];
        // console.log(VerifySquenceOfBST(sequence));

        // TODO: 24.二叉树中和为某一值的路径
        // DFS题目，也可以看做是先序遍历的题目 ,在二叉树中，dfs就相当于先序遍历
        // 思路是，利用加法，当在叶子结点的时候达到对应的数值，则把当前的路径保存到result中。
        // 注意！！！！递归函数写在函数内的好处是，递归函数在函数内调用，可以共用变量。
        function FindPath(root, expectNumber) {
            // write code here
            if (root === null) {
                return [];
            }
            let result = [];
            let path = [];
            let sum = 0;
            // 对象是指针传值，会在递归中改变，但是普通类型就不会就不会
            dfs(root, sum, result, path, expectNumber);
            return result;
        }
        // 注意，递归中的参数，是用于保存变量的。
        // 其中的逻辑是每一次递归，都是先添加当前节点，然后判断是否叶子结点和sum是否符合，符合就保存当前路径，并且也要出栈，这样才能保证路径回溯。接着进入下一层递归。而最后递归结束路径一定要出栈，保证路径回溯
        // 正是因为路径path对于每个结点push和pop才保证了路径的完整性
        function dfs(root, sum, result, path, expectNumber) {
            // 先添加根结点到路径中
            path.push(root.val);
            sum += root.val; // 先加，之后再减去
            if (root.left === null && root.right === null && sum === expectNumber) {
                // 叶子结点，总和加起来等于对应的值，则证明该路径符合要求
                result.push(path.concat()); // 注意！！！这里需要获取当前路径的拷贝。因为该路径还要回溯寻找下一个可行路径。
                path.pop(); // ！！！！！！注意，这里不能return;因为找到了新的路径，需要回退pop()!!!!
                return; // 结束当前递归
            }
            if (sum > expectNumber) {
                // 直接回退，无需继续
                path.pop();
                return;
            }
            // 否则继续递归寻找
            if (root.left !== null) {
                dfs(root.left, sum, result, path, expectNumber);
            }
            if (root.right !== null) {
                dfs(root.right, sum, result, path, expectNumber);
            }
            // 最后回退当前的路径
            path.pop();
            // 注意了！！！这里的sum是不需要再减回去，因为每一层迭代，都附带特定的sum
            // sum -= root.val;
            return;
        }
        // let tree = new Tree();
        // tree.add(10);
        // tree.add(5);
        // tree.add(12);
        // tree.add(4);
        // tree.add(7);
        // tree.add(6);
        // console.log(FindPath(tree.root, 22));
        // 方法二，把递归方法放入函数中，可以省去数据的传输
        function FindPath2(root, expectNumber) {
            var temp = [];
            // var found = false;
            var result = [];
            dfs(root, 0);
            return result;
            // 这里可以省去递归中的数据传输
            function dfs(root, sum) {
                // debugger;s
                if (!root) {
                    return;
                }
                temp.push(root.val);
                sum += root.val;
                if (!root.left && !root.right && sum === expectNumber) {
                    result.push(temp.concat());
                }
                if (root.left) {
                    dfs(root.left, sum);
                }
                if (root.right) {
                    dfs(root.right, sum);
                }
                temp.pop();
                return;
            }
        }
        // console.log(FindPath2(tree.root, 22));
        // 方法三，减法
        function FindPath(root, expectNumber) {
            const list = [],
                listAll = [];
            return findpath(root, expectNumber, list, listAll);
        }
        function findpath(root, expectNumber, list, listAll) {
            if (root === null) {
                return listAll;
            }
            list.push(root.val);
            const x = expectNumber - root.val;
            if (root.left === null && root.right === null && x === 0) {
                listAll.push(Array.of(...list));
            }
            findpath(root.left, x, list, listAll);
            findpath(root.right, x, list, listAll);
            list.pop();
            return listAll;
        }

        // TODO: 25.复杂链表的复制
        // 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。
        // 其关键在于这个random指针。

        // 关于Map
        function MapClass() {
            // 1，js创建map对象
            var map = new Map();
            // 2.将键值对放入map对象。map.set("key", value)
            let value = [1, 2, 3];
            map.set("key", value)
            map.set("key2", value)
            // 3.根据key获取map值。map.get(key)
            let key = "key";
            map.get(key);
            console.log(map.get(key));
            // 4.删除map指定对象。map.delete(key);
            map.delete(key);
            // 5.循环遍历map
            value[2] = '11213';
            map.forEach(function (item, index) {
                console.log("key", index)  //输出的是map中的value值
                console.log("value", item)  //输出的是map中的value值
            })
        }
        // MapClass();
        function RandomListNode(v) {
            this.label = v;
            this.next = null;
            this.random = null;
        }
        function RandomLinkList() {
            this.head = null;
            this.add = function (v) {
                let node = new RandomListNode(v);
                node.next = this.head;
                node.random = node; // 就指向自己！这样会有个自循环。
                this.head = node;
            }
        }
        // 方法一，标准的链表拷贝。（此方法无法解决random的深度复制）
        function Clone(pHead) {
            if (pHead === null) {
                return null;
            }
            let p = pHead;
            let p2 = new RandomListNode(pHead.label);
            p2.random = p.random;
            const reHead = p2;
            while (p !== null) {
                // 这种是在循环中直接赋值下一个节点的内容，然后在下移！！！循环的条件则是当前节点不为空
                if (p.next !== null) {
                    p2.next = new RandomListNode(p.next.label);
                    p2.next.random = p.next.random;
                } else {
                    p2.next = null;
                }
                p = p.next;
                p2 = p2.next;
            }
            return reHead;
        }
        // 方法二，递归复制（此方法无法解决random的深度复制）
        function Clone2(pHead) {
            if (!pHead) {
                return null;
            }
            var head = new RandomListNode(pHead.label);
            head.random = pHead.random;
            head.next = Clone(pHead.next);
            return head;
        }
        // 思路，相当于在创立一个副本！！！！！在第一次复制链表的时候，用map的key value来保存新旧链表的结点对应。最后在第二次的时候把random补上。
        // 注意，在map中引用类型还是指针来的，会被改动的
        function Clone3(pHead) {
            if (pHead === null) {
                return null;
            }
            let p = pHead;
            let p2 = new RandomListNode(pHead.label);
            const reHead = p2;
            const map = new Map();
            map.set(p, p2); // 利用键值对，保存对应结点的副本！！！如(A,A'),(B,B'),因为AB是指针，会中途改变。所以最后变成(A-B-C-D...,A'-B'-C'-D'...);
            while (p !== null) {
                if (p.next !== null) {
                    p2.next = new RandomListNode(p.next.label);
                } else {
                    p2.next = null; // 结束
                }
                // 各自移动一个单位，走到对应的位置
                p = p.next;
                p2 = p2.next;
                // 用map保存对应的结点
                map.set(p, p2);
            }
            // 第二次遍历，利用map把random补上
            p = pHead;
            p2 = reHead;
            while (p !== null) {
                p2.random = map.get(p.random); // 相当于找到对应的副本
                p = p.next;
                p2 = p2.next;
            }
            return reHead;
        }
        function Clone4(pHead) {
            cloneNodes(pHead);
            connectRandom(pHead);
            return reconnectNodes(pHead);
        }
        function cloneNodes(pHead) {
            // 复制链表，A-A'-B-B'....
            let pNode = pHead;
            while (pNode !== null) {
                const newNode = new RandomListNode(pNode.label);
                newNode.next = pNode.next;
                pNode.next = newNode;
                pNode = newNode.next;
            }
        }
        function connectRandom(pHead) {
            // 设置random指针
            let pNode = pHead;
            while (pNode !== null) {
                if (pNode.random !== null) {
                    pNode.next.random = pNode.random.next;
                }
                pNode = pNode.next.next;
            }
        }
        function reconnectNodes(pHead) {
            // 拆开链表
            let pNode = pHead;
            let newNodeHead = null,
                newNode = null;
            if (pNode !== null) {
                newNodeHead = newNode = pNode.next;
                pNode.next = newNode.next;
                pNode = newNode.next;
            }
            while (pNode !== null) {
                newNode.next = pNode.next;
                newNode = newNode.next;
                pNode.next = newNode.next;
                pNode = pNode.next;
            }
            return newNodeHead;
        }


        // let list1 = new RandomLinkList();
        // list1.add(7);
        // list1.add(5);
        // list1.add(3);
        // list1.add(1);
        // console.log(list1);
        // console.log(Clone(list1.head));
        // console.log(Clone2(list1.head));
        // console.log(Clone3(list1.head));
        // console.log(Clone4(list1.head));
        // 改变原链表
        // list1.head.next.next.label = 444;
        // console.log(list1.head.next.next.label);

        // TODO: 26.二叉搜索树与双向链表
        // 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
        // 因为二叉树是左大右小，而一个排序好的的双向链表也就是二叉树从最左到最右的序列！！！
        // 换个思路，也就是将二叉树变成一个有序的链表，对于二叉树从小到大也就是树从左到右
        function Convert(pRootOfTree) {
            if (pRootOfTree === null) {
                return null;
            }
            let pLast = null; // 初始化的时候，对于根结点是没有父节点的，所以为null
            pLast = ConvertNode(pRootOfTree, pLast);
            let head = pLast;
            // 从尾节点寻根找到最前面的头结点
            while (head && head.left !== null) {
                head = head.left;
            }
            return head;
        }
        // 因为中序遍历才能从小到大，所以需要递归，
        // 使用递归。对于一个抽离出来的结点。根结点的pre指向左子树，next指向右子树。而左子树的next指向根，右子树的pre指向根结点
        // 将左子树构成双向链表，返回的是左子树的尾结点，将其连接到root的左边；将右子树构成双向链表，将其追加到root结点之后，并返回尾结点；
        // 之所以递归返回尾节点，是为了更好的拼接在根结点的左边。对于右子树的东西，直接连接到根结点之后即可。但最后还是要返回尾节点。
        // 函数最后返回当前树转化为双向链表的最后非空结点
        // 入参node为当前树的父节点，注意！！！这里需要增加多一个参数，用来保存当前节点对应的上一个节点的pLast
        function ConvertNode(node, pLast) {
            if (node === null) {
                return null;
            }
            // 将左子树构成双向链表，返回的是左子树的尾结点，将其连接到root的左边；
            if (node.left) {
                // 如果存在左节点，则需要更新pLast，用于下一层
                // 注意！！！！在存在左节点的时候，是不影响上一层的最后一个尾节点，所以pLast需要安搬不动传给下一层递归。
                // 如右左结构（4-7-6-5），左子树中的n个左子树，最后还是要指向父节点的！！！！也就是最后5要指向4！！
                pLast = ConvertNode(node.left, pLast);
            }
            node.left = pLast; // 如果有新的左子树则使用新的左子树的尾节点，如果没有左子树，就采用上一层的尾节点
            if (pLast !== null) {
                // 如果是空节点，就不能指向当前node！主要是leftLast.right会报错！
                pLast.right = node; // 完成左子树的拼接
            }
            // 将右子树构成双向链表，将其追加到root结点之后，并返回尾结点；
            pLast = node; // 更新pLast。在递归右子树的时候，对于右子树而言当前层的最后一个节点是父节点。
            let rightLast = null;
            if (node.right) {
                rightLast = ConvertNode(node.right, pLast);
            }
            if (rightLast === null) {
                return node; // 如果右子树不存在，则当前树最后一个结点就是父节点
            } else {
                return rightLast;
            }
        }
        // 简写
        function ConvertNode2(node, pLast) {
            if (!node) {
                return null;
            }
            if (node.left) {
                pLast = ConvertNode(node.left, pLast);
            }
            node.left = pLast;
            if (pLast) {
                pLast.right = node;
            }
            pLast = node;
            if (node.right) {
                // pLast = ConvertNode(node.right,node);
                pLast = ConvertNode(node.right, pLast);
            }
            return pLast;
        }
        // 简写
        function Convert2(pRootOfTree) {
            if (!pRootOfTree) {
                return null;
            }
            var lastNode = null;
            lastNode = ConvertNode(pRootOfTree);
            var head = lastNode;
            while (head && head.left) {
                head = head.left;
            }
            return head;
            function ConvertNode(node) {
                if (!node) {
                    return;
                }
                if (node.left) {
                    lastNode = ConvertNode(node.left);
                }
                node.left = lastNode;
                if (lastNode) {
                    lastNode.right = node;
                }
                lastNode = node;
                if (node.right) {
                    lastNode = ConvertNode(node.right);
                }
                return lastNode;
            }
        }
        // let tree = new Tree();
        // tree.add(4);
        // tree.add(2);
        // tree.add(5);
        // tree.add(1);
        // tree.add(3);
        // tree.add(6);

        // tree.add(4);
        // tree.add(6);
        // tree.add(5);
        // console.log(tree.root);
        // console.log(Convert2(tree.root));

        // TODO: 字符串的排列
        // 输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。同时也需要去重
        // 这是一个全排列，时间复杂度自然也是n!。
        // 其思路就是填空格，比如ABC，第一个位置则可以从ABC中选取一个，第二个位置则需要去掉第一个空的字符，然后选择一个，最后一个位置则只能填剩余的唯一一个。
        function Permutation(str) {
            // write code here
            if (str.length <= 0) {
                return [];
            }
            let res = [];
            let strArr = str.split("");
            let curStr = '';
            res = Permutate(strArr, curStr, res);

            return res;
        }
        // 参数arr是需要组合的字符数组；curStr和res就类似之前的path和pathAll一样。curStr指的是当前组合的字符串，而res则是所有的字符组合。
        // 过程是，取出当前arr中的第i个字符s，然后从arr中删除s，在剩余的arr中继续递归。
        // 此递归比较特殊，是在循环中递归，所以时间复杂度也是n!。在循环中变更状态然后给到下一层递归，然后恢复原来的状态继续循环进行下一次递归。每次递归的结束，就是一个组合的完成，保存下来最后返回。
        function Permutate(arr, curStr, res) {
            if (arr.length === 0) {
                // 证明已经遍历完
                res.push(curStr);
                return res;
            }
            let set = new Set();
            for (let i = 0; i < arr.length; i++) {
                let char = arr[i];
                if (set.has(char)) {
                    // 需要进行预处理，相同字符不需要重复，比如abb',和ab'b是一样的！！
                    continue;
                }
                set.add(char);
                arr.splice(i, 1); // 删掉下标为i的字符
                curStr += char; // 组合中新增当前字符
                Permutate(arr, curStr, res); // 进入下一层递归。
                // 接下来还原数组，还原数组的目的在于下一次for循环。
                curStr = curStr.slice(0, curStr.length - 1); // 恢复字符串
                arr.splice(i, 0, char);
            }
            return res;
        }
        // 关于Set
        function _Set() {
            let set = new Set();
            // add()增   delete ()删   has()查
            // 转化为数组[...new Set([1,2,3,4,5])]
        }
        // let str = 'aabc';
        // console.log(Permutation(str));
        // let arr = [1, 2, 3];
        // arr.splice(0, 1);
        // console.log(arr);
        // arr.splice(0, 0, 1);
        // console.log(arr);


        // TODO: 28.数组中出现次数超过一半的数字
        function MoreThanHalfNum_Solution(numbers) {
            let obj = {};
            numbers.forEach((item, index) => {
                if (obj.hasOwnProperty(item)) {
                    obj[item]++;
                } else {
                    obj[item] = 1;
                }
            })
            let max = 1;
            let len = numbers.length / 2;
            let re = 0;
            for (let item in obj) {
                if (obj[item] > len) {
                    re = item;
                }
            }
            return re;
        }
        // let arr = [1,2,3,2,2,2,5,4,2];
        // console.log(MoreThanHalfNum_Solution(arr));


        // TODO: 第K大的数或者第K小的数（补充）
        // 基于快速排序的方法，时间复杂度为o(n)
        // 选一个枢轴点，用快排的方法将数组分为两部分，位于枢轴点左边的数都比它大，位于枢轴点右边的数都比它小，
        // 如果枢轴点的索引刚好是k-1,则此时它对应的就是数组的第k大的数；
        // 快排
        function quickSort(arr, left, right) {
            if (left >= right) {
                return;
            }
            let key = partition(arr, left, right); // 参数arr的作用在于保存不断迭代变动的数组
            // 如果是第k大（第k大则递减排序，第k小则递增排序）只需要判断key === k-1。是则返回。
            if (key > left) {
                // 保证key不是指向数组的第一个。（其实也可以省略，因为递归的下一层会判断结束的）
                quickSort(arr, left, key - 1); // key-1是排除key本身
            }
            if (key < right) {
                quickSort(arr, key + 1, right);
            }
        }
        // 注意！！！partition已经改变原数组，将其进行分边，然后返回中间的哨兵。
        // 同时有个特性！！！partition每次返回的key对应的值，是已经找准位置的了！！！
        // 即每一次partition就确定一个值的位置！！！
        function partition(arr, left, right) {
            let key = arr[left]; // 取第一个作为哨兵
            // 交换的思路是，在高处找到比key小的数，就放在哨兵处。在低位找到比key大的数则放在刚刚高处的位置。最后数轴点归位。
            // 就是不断将高处的小值搬到低处，然后再把低处的大值搬到高处。因为一开始哨兵left让出位置，最后利用key来复原，同时返回当前的index
            while (left < right) { // 扫描一遍
                while (left < right && arr[right] >= key) { // left < right是为了避免越界
                    // 注意，这里的arr[right]>=key是用于区分递增还是递减序列
                    right--;
                }
                // 当在高处找到一个小的值时候，此时的right正指向这个值！
                // 将这个小的值放入低位中
                arr[left] = arr[right]; // 在循环结束的时候也就是left=right，实际上也是自己赋值自己，不影响的
                while (left < right && arr[left] <= key) {
                    left++;
                }
                // 当在低处找到一个大的值时候，此时的left正指向这个值！
                // 将低处的大值放到高处
                arr[right] = arr[left];
            }
            // 这个过程就是一个搬来搬去的过程，由最开是的哨兵让出位置，然后高低位移动。而现在需要还原哨兵的位置
            // 而循环结束的条件则是left=right，也就是左右全部交换完，最后剩下的就是哨兵的位置了！！！
            arr[left] = key;
            return left;
        }

        // 第k大
        // 利用partition分边的方法，因为每一次分边，都可以定位一个元素！
        function findKMax(arr, k) {
            let left = 0;
            let right = arr.length - 1;
            let key = partition(arr, left, right);
            // 因为每次partition可以确定key的定位，所以只要找到第k个的key即可！
            while (key !== k - 1) {
                if (key > k - 1) {
                    key = partition(arr, left, key - 1); // 在这里是允许left === key-1，也就是只剩最后一个元素，而partition也会将这个元素的index返回
                } else {
                    key = partition(arr, key + 1, right);
                }
            }
            return arr[key];
        }
        // let arr = [4, 3, 2, 1, 5];
        // quickSort(arr, 0, 4);
        // console.log(findKMax(arr,2));
        // console.log(arr);

        // TODO: 29.最小的K个数
        // 其思路和最小第k个树一样！！！只要把第k个数找出来，返回左边的部分即可
        function GetLeastNumbers_Solution(input, k) {
            // 注意注意！！！！！！太坑了！！！！！一定要对入参进行校验
            // 每次刷题，都务必对入参进行校验，一旦入参是奇奇怪怪的数，很可能导致算法的瘫痪。
            if (input.length <= 0 || k > input.length || k < 1) {
                return [];
            }
            let left = 0;
            let right = input.length - 1;
            let key = partition(input, left, right);
            while (key !== k - 1) {
                if (key > k - 1) {
                    key = partition(input, left, key - 1);
                } else {
                    key = partition(input, key + 1, right);
                }
            }
            // 关于slice，数组和字符串都可以使用。
            // slice() 方法可从已有的数组中返回选定的元素。slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
            return input.slice(0, key + 1).sort(function (a, b) { return a - b });
        }
        // let arr = [4, 5, 1, 6, 2, 7, 3, 8];
        // console.log(GetLeastNumbers_Solution2(arr, 4));


        // TODO: 30.连续子数组的最大和
        // {6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。
        // 这道题只需要用动态规划就搞定，f(n)指包含当前n的最大连续子数组和
        // 当i=0时，或者sum(i-1)<=0时，sum(i)=array[i];
        // 当i≠0时，或者sum(i-1)>0时，sum(i)=sum(i-1)+array[i];
        function FindGreatestSumOfSubArray(array) {
            let len = array.length;
            if (len <= 0) {
                return;
            }
            let arr = [];
            arr[0] = array[0];
            let max = arr[0];
            for (let i = 1; i < len; i++) {
                // 从第二个开始
                if (arr[i - 1] < 0) { // 如果前面的组合为负数，就没必要携带了
                    arr[i] = array[i]; // 当前的值就
                } else {
                    arr[i] = arr[i - 1] + array[i]
                }
                if (arr[i] > max) {
                    max = arr[i];
                }
            }
            return max;
        }
        // let arr = [1, -2, 3, 10, -4, 7, 2, -5];
        // console.log(FindGreatestSumOfSubArray(arr));

        // TODO: 31.整数中出现1的次数
        // 从1 到 n 中1出现的次数。1~13中包含1的数字有1、10、11、12、13因此共出现6次,
        // 思路可以讲所有的整数合并成一个字符串，比如12345678910111213，然后再统计字符串1的个数
        function NumberOf1Between1AndN_Solution(n) {
            if (n <= 0) {
                return 0;
            }
            let arr = [];
            for (let i = 1; i <= n; i++) {
                arr.push(i);
            }
            let str = arr.join("");
            let len = str.length;
            let re = 0;
            for (let i = 0; i < len; i++) {
                if (str.charAt(i) == 1) {
                    re++;
                }
            }
            return re;
        }
        // console.log(NumberOf1Between1AndN_Solution(13));

        // TODO: 32.把数组排成最小的值
        // 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
        // 例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
        // 注意！！！！字符串比较按照字典排序进行比较了。
        // 思路，对字符串进行排序，排序的规则是每两个字符组合一起，有前后之分，看谁小就谁排在前面
        // 因为两者组合，才知道谁更适合放在前面！！！
        function PrintMinNumber(numbers) {
            if (numbers.length <= 0) {
                return "";
            }
            numbers.sort((a, b) => {
                let str1 = "" + a + b;
                let str2 = "" + b + a;
                return str1 - str2;
            })
            let re = parseInt(numbers.join(""));
            return re;
        }
        // let arr = [3, 32, 321];
        // console.log(PrintMinNumber(arr));

        // TODO: 33.丑数（求按从小到大的顺序的第N个丑数）
        // 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数
        function isUgly(num) {
            while (num % 2 === 0) num /= 2;
            while (num % 3 === 0) num /= 3;
            while (num % 5 === 0) num /= 5;
            return num === 1;
        }
        // 思路，如果逐个去遍历，时间复杂度就太大了。所以使用动态规划，以空间换时间
        // 把前面的丑数存着，生成后面的丑数，t2,t3,t5是判断点，用于判断从何处开始选出并乘以对应因子肯定会大于当前数组中最大丑数，而前面的丑数不用考虑。
        // 也就是每一个丑数，都是前一个丑数*2 *3 *5的结果！！！
        // 1234689，比如4是2*2，6是3*2，8是4*2。。。对于每一个丑数来说，就是2*i，3*i,5*i，只是在其中找出一个最小值作为当前层的丑数。
        function GetUglyNumber_Solution(index) {
            if (index <= 0) {
                return 0;
            }
            let res = [1];
            // 所有的丑数都是p2,p3,p5的n的乘积
            // p2,p3,p5初始值为0！！！因为这些指向的是上一个丑数的下标！！！
            let p2 = 0;
            let p3 = 0;
            let p5 = 0;
            for (let i = 1; i < index; i++) {
                // 动态规划，就是基于原先f(n/2)orf(n/3)orf(n/5)的值，因为递增所以选择最小的。res这个数组保存的都是丑数
                res[i] = Math.min(res[p2] * 2, res[p3] * 3, res[p5] * 5);
                // p2,p3,p5指针的移动，是在当前指针对应下一个丑数已经被res[i]获取了，那么指针移动指向下一个丑数，然后诞生新的丑数
                if (res[p2] * 2 === res[i]) p2++;
                if (res[p3] * 3 === res[i]) p3++;
                if (res[p5] * 5 === res[i]) p5++;
            }
            return res[index - 1]; // 下标
        }

        // TODO: 34.第一个只出现一次的字符
        // 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）
        // 这道题类似于去重，用对象既可以，最后找出出现为1的值
        // 注意，对象的属性的添加，for-in的迭代顺序不是按定义对象时的顺序，而直接输出对象或用Object.keys遍历都是一样的效果。
        // 也就是对象的属性名，是按照ASCII码升序排序的！！如，obj={'a':xx,'1':xx}，最后输出的结果是obj={'1':xx,'a':xx}；
        // 因为题目有说，全部由字母组成。所以不用考虑这个问题
        function FirstNotRepeatingChar(str) {
            if (str.length <= 0) {
                return -1;
            }
            let hash = {};
            let len = str.length;
            // 不需要讲str转化为数组，这样会浪费空间
            for (let i = 0; i < len; i++) {
                if (!hash[str.charAt(i)]) {
                    hash[str.charAt(i)] = 1;
                } else {
                    hash[str.charAt(i)]++;
                }
            }
            // 因为要返回index具体位置。所以还需要遍历一次原str
            for (let i = 0; i < len; i++) {
                if (hash[str[i]] === 1) {
                    return i;
                }
            }
            return -1;
        }
        // let str = "aaab";
        // console.log(FirstNotRepeatingChar(str));

        // TODO: 35.数组中的逆序对



        // TODO: 36.两个链表的一个公共结点
        // 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
        // 其实题目意思就是，两条线合并成一条线，找出合并的那个结点！！！
        // 也就是两个链表会想交并且后续重复。
        // 就算两个链表长度不同，但是重合点到结尾是相同长度的。
        // 方法一，先在长的链表上跑，直到长的和短的一样长，再一起跑，判断节点相等的时候就可以了。
        function FindFirstCommonNode(pHead1, pHead2) {

        }
        // 方法二，因为公共结点一定是出现在两个链表的结尾。所以可以用两个辅助栈，pop之后看是否有相同的值
        // 注意！！！！下次遇到这种开头不一样，但结尾一样的东西。可以使用栈！！！！
        function FindFirstCommonNode(pHead1, pHead2) {
            if (pHead1 === null || pHead2 === null) {
                return null;
            }
            let stack1 = [];
            let stack2 = [];
            let p1 = pHead1;
            let p2 = pHead2;
            while (p1 !== null) {
                stack1.push(p1);
                p1 = p1.next;
            }
            while (p2 !== null) {
                stack2.push(p2);
                p2 = p2.next;
            }
            // 栈不为空
            let re = null;
            while (stack1.length > 0 && stack2.length > 0) {
                let temp1 = stack1.pop();
                let temp2 = stack2.pop();
                if (temp1.val === temp2.val) {
                    re = temp1;
                    continue;
                } else {
                    break; // 一旦遇到不相同，就可以退出循环了
                }
            }
            return re;
        }
        // let list1 = new LinkList();
        // list1.add(1);
        // list1.add(2);
        // list1.add(3);
        // list1.add(4);
        // let list2 = new LinkList();
        // list2.add(1);
        // list2.add(2);
        // list2.add(3);
        // list2.add(4);
        // console.log(FindFirstCommonNode(list1.head, list2.head));

        // TODO: 37.数字在排序数组中出现的次数
        function GetNumberOfK(data, k) {
            if (data.length < 1) {
                return 0;
            }
            let re = 0;
            let flag = false;
            for (let i = 0; i < data.length; i++) {
                if (data[i] === k) {
                    flag = true;
                    re++;
                } else {
                    if (flag) {
                        break;
                    }
                }
            }
            return re;
        }

        // TODO: 38.二叉树的深度
        // 无需过多的判断，只需要找到递归结束条件是当前节点为空，就返回0。而在递归回溯的时候，自然会逐步+1的
        function TreeDepth(pRoot) {
            if (pRoot === null) {
                return 0;
            }
            // 无需判断是否存在左右子树，让它进入下一层判断就行。取左右子树最大值，然后当前层+1
            return Math.max(TreeDepth(pRoot.left), TreeDepth(pRoot.right)) + 1;
        }

        // TODO: 39.平衡二叉树
        // 判断该二叉树是否是平衡二叉树，也就是高度差不大于1
        function IsBalanced_Solution(pRoot) {
            if (pRoot === null) {
                return true;
            }
            let left = TreeDepth(pRoot.left);
            let right = TreeDepth(pRoot.right);
            if (Math.abs(left - right) > 1) {
                return false;
            }
            return IsBalanced_Solution(pRoot.left) || IsBalanced_Solution(pRoot.right)
        }

        // TODO: 40.数组中只出现一次的数字
        // 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
        // 这道题和之前的字符只出现一次类似，用对象保存比较
        function FindNumsAppearOnce(array) {
            let obj = {};
            array.forEach((item, index) => {
                if (obj.hasOwnProperty(item)) {
                    obj[item]++;
                } else {
                    obj[item] = 1;
                }
            })
            let re = [];
            for (let key in obj) {
                if (obj[key] === 1) {
                    re.push(key);
                }
            }
            return re;
        }
        // 方法二，
        // 使用js中的indexOf()和lastIndexOf(),只要两个相等，就是只出现一次的数。
        function FindNumsAppearOnce(array) {
            let re = [];
            for (let i = 0; i < array.length; i++) {
                if (array.indexOf(array[i]) === array.lastIndexOf(array[i])) {
                    re.push(array[i]);
                }
            }
            return re;
        }

        // TODO: 41.和为S的连续正数序列
        // 如100的序列:18,19,20,21,22。这里面有个规律，就是连续，就可以(a+b)/2*n = S;
        // 假设序列的开始数字为a,结束数字为a+i，那么有(a+i-a+1)*(a+a+i)/2=sum
        // 也就是(i+1)*(2*a+i)=2*sum
        function FindContinuousSequence(sum) {
            if (sum < 3) {
                return [];
            }
            // 比如100，51+.....都不可能满足条件的了。
            let half = sum / 2;
            let re = [];
            let temp = [];
            for (let a = 1; a < half; a++) {
                let i = 1;
                while ((i + 1) * (2 * a + i) < 2 * sum) {
                    i++; // 以a为开始，寻找连续序列
                }
                if ((i + 1) * (2 * a + i) === 2 * sum) {
                    temp.push({ a: a, i: i }); // 保存初始值和增量
                }
                // 剩余的就是超过的，也就是不符合的，那么就继续循环。
            }
            temp.forEach((item) => {
                let list = [item.a];
                for (let i = 1; i <= item.i; i++) {
                    list.push(item.a + i);
                }
                re.push(list);
            })
            return re;
        }
        // console.log(FindContinuousSequence(100));


        // TODO: 42.和为S的两个数字
        // 之前是在混乱的数组中找出和为S，可以利用map减少查找时间。
        // 而现在这道题，序列是有序的！！！有序序列可以从两头开始找，如果和大就右边缩，如果和小就左边增。
        // 因为乘积最小，所以相距最远，乘积最小。也就是第一个找到的就是乘积最小的
        function FindNumbersWithSum(array, sum) {
            if (array.length <= 0) {
                return [];
            }
            let head = 0;
            let tail = array.length - 1;
            // 至少两个以上
            while (head < tail) {
                if (array[head] + array[tail] > sum) {
                    tail--;
                } else if (array[head] + array[tail] < sum) {
                    head++;
                } else {
                    return [array[head], array[tail]];
                }
            }
            return [];
        }

        // TODO: 43.左旋转字符串
        // 例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”
        function LeftRotateString(str, n) {
            // 注意，在预处理的时候，需要判断str不为空
            // 因为如果str不存的时候，是无法.length的！！！！！！！
            if (!str || str.length === 0) {
                return '';
            }
            n = n % str.length; // 防止越界！！！！！！
            let head = str.slice(n);
            let tail = str.slice(0, n);
            return '' + head + tail;
        }
        // let str = "abcdefg";
        // console.log(LeftRotateString(str, 2));

        // TODO: 44.翻转单词顺序列
        // 可以使用栈来进行调换顺序，也可以直接使用reverse方法
        function ReverseSentence(str) {
            if (!str || str.length === 0) {
                return '';
            }
            let arr = str.split(" ");
            arr.reverse();
            return arr.join(" ");
            // write code here
        }

        // TODO: 45.扑克牌顺子
        // 大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。
        // 1.最大和最小之差不超过5。2.这5个数当中不能有重复的数字。
        function IsContinuous(numbers) {
            // 顺子是五个数，进行预处理
            if (!numbers || numbers.length !== 5) {
                return false;
            }
            let max = 0;
            let min = 14;
            let unique = new Array(13);
            let res = false;
            // 注意！！！！！forEach是无法return和break来结束的！
            for (let i = 0; i < numbers.length; i++) {
                if (numbers[i] > 13 || numbers[i] < 0) {
                    return false;
                }
                if (!unique[numbers[i]]) {
                    unique[numbers[i]] = 1;
                } else {
                    unique[numbers[i]]++;
                }
                if (numbers[i] > max) {
                    max = numbers[i];
                }
                if (numbers[i] < min && numbers[i] !== 0) {
                    min = numbers[i];
                }
            }
            if (max - min >= 5) {
                return false;
            }
            // 大王小王不能多于四个
            if (unique[0] > 4) {
                return false;
            }
            for (let i = 1; i < unique.length; i++) {
                if (unique[i] > 1) {
                    return false;
                }
            }
            return true;
        }
        // let numbers = [1,0,0,5,0];
        // console.log(IsContinuous(numbers));

        // TODO: 46.孩子们的游戏
        // 随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版
        // 也就是给出一个数组，每次点到m-1的时候出队，继续下一次。
        // 下标需要注意！！！编号是0-(n-1)。并且报数是0-(m-1)
        function LastRemaining_Solution(n, m) {
            if (n <= 0 || m <= 1) {
                return -1;
            }
            let arr = new Array(n); // 一共n个小朋友
            for (let i = 0; i < arr.length; i++) {
                arr[i] = i;
            }
            let index = 0;
            // 注意，arr.length是变动的
            while (arr.length > 1) {
                index = (index + m - 1) % arr.length;
                arr.splice(index, 1);
            }
            return arr[0];
        }
        // console.log(LastRemaining_Solution(5,3));

        // TODO: 47.求n的阶层
        // 不得使用循环
        function Sum_Solution(n) {
            // write code here
            if (n <= 0) {
                return 0;
            }
            let sum = 0; // 这个不是引用结构，所以指针传递
            return _Sum(n, sum);
        }
        function _Sum(n, sum) {
            if (n < 1) {
                return sum;
            }
            sum += n;
            return _Sum(n - 1, sum);
        }
        // 方法二
        function Sum_Solution2(n) {
            if (n <= 0) {
                return 0;
            }
            return Sum_Solution(n - 1) + n;
        }
        // console.log(Sum_Solution(4));

        // TODO: 48.不用加减乘除做加法


        // TODO: 49.将字符串转换成整数
        // 如果是合法的数值表达则返回该数字，否则返回0
        // +2147483647为2147483647，，，1a33则是0
        // 注意，有个关键就是，字符串乘以一个数，会自动转化数字类型的！！！！
        function StrToInt(str) {
            // write code here
            str = str + '';
            if (!str || str.length <= 0) {
                return 0;
            }
            let flag = 1; // 负数为true，
            let index = 0; // 判读有没有符号，有符号就下一个获取数值
            if (str[0] === '+' || str[0] === '-') {
                index = 1; // 从下一个位置开始判断
            }
            if (str[0] === '-') {
                flag = -1;
            }
            let re = '';
            for (let i = index; i < str.length; i++) {
                if (str[i] <= 9 || str[i] >= 0) {
                    re += str[i];
                } else {
                    return 0;
                }
            }
            if (!re) {
                return 0; // 如果正负号后面没有数字，也需要返回0
            }
            return flag * re; // 注意！！！！！要字符串转化为数字，可以用乘法
        }
        // console.log(StrToInt('+1a33'));

        // TODO: 50.数组中重复的数字
        // 查重问题，所有数字都在0到n-1的范围内。
        function duplicate(numbers, duplication) {
            //这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
            //函数返回True/False
            if (!numbers || numbers.length <= 0) {
                return false;
            }
            let obj = {};
            for (let i = 0; i < numbers.length; i++) {
                if (numbers[i] < 0 || numbers[i] > numbers.length - 1) {
                    return false;
                }
                if (!obj[numbers[i]]) {
                    obj[numbers[i]] = 1;
                } else {
                    duplication[0] = numbers[i];
                    return true;
                }
            }
            return false;
        }

        // TODO: 51.构建乘积数组
        // 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。
        // 规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];
        // 也就是对应位置的A[i]不取，因为不能用除法，所以可以借助空间来实现，一个从左到右，一个从右到左。
        // B[i]=left[i-1]right[i+1]; 相当于一个从左乘到右，一个从右乘到左，就是不需要当前第i个乘积而已。
        function multiply(array) {
            if (array.length <= 0) {
                return [];
            }
            let re = [];
            let head = [];
            let tail = [];
            // 从左到右 ，相当于采用动态规划
            for (let i = 0; i < array.length; i++) {
                if (i === 0) {
                    head[i] = array[0];
                } else {
                    head[i] = head[i - 1] * array[i];
                }
            }
            for (let i = array.length - 1; i >= 0; i--) {
                if (i === array.length - 1) {
                    tail[i] = array[array.length - 1];
                } else {
                    tail[i] = tail[i + 1] * array[i];
                }
            }
            for (let i = 0; i < array.length; i++) {
                if (i === 0) {
                    re[i] = tail[i + 1];
                }
                else if (i === array.length - 1) {
                    re[i] = head[i - 1];
                } else {
                    re[i] = head[i - 1] * tail[i + 1];
                }
            }
            return re;
        }
        // 方法二，就是用一个数值来作为tail
        function multiply2(array) {
            if (!array || array.length <= 0) {
                return [];
            }
            let re = [];
            re[0] = 1;
            // 计算前i - 1个元素的乘积，re[i]保存的是left[i-1]
            // 如果不这样子，到时re[i-1]就会越界，很难处理
            for (let i = 1; i < array.length; i++) {
                re[i] = re[i - 1] * array[i - 1];
            }
            let temp = 1;
            // 从倒数第二个开始
            for (let i = array.length - 2; i >= 0; i--) {
                // 这里的意思也是B[i]=left[i-1]right[i+1];
                temp = temp * array[i + 1]; // temp指的是right[i+1];，而re[i-1]是left[i-1]
                re[i] = re[i] * temp;
            }
            return re;
        }
        // let arr = [1, 2, 3, 4, 5];
        // console.log(multiply(arr));
        // console.log(multiply2(arr));

        // TODO: 52.正则表达式匹配
        // 请实现一个函数用来匹配包括'.'和'*'的正则表达式。
        function match(s, pattern) {
            //s, pattern都是字符串
            if (!s && !pattern) {
                return true;
            }
            if (!pattern || pattern.length === 0) {
                return false;
            }
            const reg = new RegExp('^' + pattern + '$');
            return reg.test(s);
        }

        // TODO: 53.表示数值的字符串
        function isNumeric(s) {
            return s.match(/[+-]?\d*(\.\d*)?([eE][+-]?\d+)?/g)[0] === s;
        }

        // TODO: 54.字符流中第一个不重复数字
        // 用哈希表来统计次数，也就是对象
        //Init module if you need
        let map = {}; // 可以通过这样定义一个全局变量
        function Init() {
            map = {};
        }
        //Insert one char from stringstream
        function Insert(ch) {
            if (!map[ch]) {
                map[ch] = 1;
            } else {
                map[ch]++;
            }
        }
        //return the first appearence once char in current stringstream
        function FirstAppearingOnce() {
            for (let key in map) {
                if (map[key] === 1) {
                    return key;
                }
            }
            return '#'; // 如果没有就返回#
        }

        // TODO: 55.链表中环的入口结点
        // 关于环，设置快慢指针，都从链表头出发，快慢指针分别每走2步和1步。假设有换，则一定会相遇。接着让两个指针分别从相遇点和链表头出发，改成同步走1步，最终会相遇于环入口。
        // 注意！！！在js中是无法判断对象是否相同，只能判断指针是否指向同一个位置！！！！
        function EntryNodeOfLoop(pHead) {
            // write code here
            if (!pHead) {
                return null;
            }
            let slow = pHead;
            let fast = pHead;
            // 遍历链表直到相遇，但是注意，还需要判断链表是否结束
            // 以快指针为判断条件，快指针如果遍历完链表则证明无环。如果快指针不会越界，那么慢的更不会
            while (fast !== null && fast.next !== null) {
                fast = fast.next.next; // 快指针是慢指针的两倍
                slow = slow.next;
                // 注意！！！js中不能判断对内的内容是否一样，只能判断指针是否指向同个地址
                if (fast === slow) {
                    // 两者相遇，证明有环。然后其中一个指针回到原点，并同步走。找下一次相遇
                    fast = pHead;
                    while (fast !== slow) {
                        // 已经证明有环，所以无需判断越界
                        fast = fast.next;
                        slow = slow.next;
                    }
                    return fast;
                }
            }
            return null;
        }
        // 方法二，但会影响原链表，就是断链法。最后一个被访问的结点一定是入口结点。

        // TODO: 56.删除链表中重复的结点
        // 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
        // 先查重再重新变更链表
        function deleteDuplication(pHead) {
            // write code here
            if (!pHead) {
                return null;
            }
            let p = pHead;
            let obj = {};
            while (p !== null) {
                if (obj[p.val]) {
                    obj[p.val]++;
                } else {
                    obj[p.val] = 1;
                }
                p = p.next;
            }
            p = pHead;
            // 前一个可以利用一个空结点代替！！！！
            let pre = new ListNode(null);
            let re = pre;
            pre.next = pHead;
            while (p !== null) {
                if (obj[p.val] > 1) {
                    pre.next = p.next; // 相当于改变pre的指向
                    p = p.next;
                } else {
                    p = p.next;
                    pre = pre.next;
                }
            }
            return re.next;
        }
        // let list = new LinkList();
        // list.add(3);
        // list.add(2);
        // list.add(1);
        // list.add(1);
        // list.add(1);
        // console.log(deleteDuplication(list.head));

        // TODO: 57.二叉树的下一个结点
        // 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
        // 中序遍历，左根右。当前的结点，一定是在遍历完左子树才到自己的！！！！！那么接下来一定是会遍历右子树的！！！右子树就是其中最的左子结点了。
        // 如果没有右子树的情况下，证明当前结点遍历结束后，会从父节点中寻找。1.如果自己是左结点，那么下个结点就是父节点了。2.如果自己是右结点，那么就需要往上寻找，找到一个存在左节点的祖先结点。
        // 这道题需要画图解答
        /*function TreeLinkNode(x){
            this.val = x;
            this.left = null;
            this.right = null;
            this.next = null; // 指向父结点的指针
        }*/
        function GetNext(pNode) {
            // write code here
            if (pNode === null) {
                return null;
            }
            // 中序遍历，下一个结点一定不会出现在左子树。
            if (pNode.right !== null) {
                // 存在右子树
                let reNode = pNode.right;
                // 如果存在左子树就获取最底的左子树，否则就是本身这个右子结点
                while (reNode.left !== null) {
                    reNode = reNode.left;
                }
                return reNode;
            }
            // 不存在右子树，分两种情况
            // 往父节点开始找
            let parent = pNode.next;
            while (parent !== null) {
                if (pNode === parent.left) {
                    return parent; // 其实就是寻找一个有左子树的父节点
                }
                parent = parent.next; // 继续往上寻找父节点
                pNode = pNode.next; // 自身也往上
            }
            return null; // 最后找不到，证明自己是最后了
        }

        // TODO: 58.对称二叉树
        // 用递归来实现，只观察第一层。
        function isSymmetrical(pRoot) {
            // write code here
            if (pRoot === null) {
                return true;
            }
            return _isSymmetrical(pRoot.left, pRoot.right);
        }
        function _isSymmetrical(left, right) {
            if (left === null && right === null) {
                return true; // 这个才是真正递归结束条件，都遍历完没问题，才能真正返回true！！！
            }
            if (left === null || right === null) {
                return false;
            }
            if (left.val !== right.val) {
                return false; // 如果是左右子树相等的情况下，留给下一层判断。只有最后遍历完才返回true
            }
            // 注意，在这里left.val = right.val是不能返回true的！！！因为一旦返回true，就不会有下面的判断了！
            return _isSymmetrical(left.left, right.right) && _isSymmetrical(left.right, right.left)
        }

        // TODO: 59.按之字形顺序打印二叉树
        // 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
        // 这就是广度遍历的改进版
        // 以下是广度遍历，可以看到是采用一个队列的方式
        function BreadthTraversal(pRoot) {
            if (pRoot === null) {
                return [];
            }
            let re = [];
            let queue = [];
            queue.push(pRoot);
            while (queue.length > 0) {
                let node = queue.shift();
                re.push(node.val);
                if (node.left) {
                    queue.push(node.left);
                }
                if (node.right) {
                    queue.push(node.right);

                }
            }
            return re;
        }
        // 方法二
        // 奇数行从左至右，在偶数行从右至左
        // 两个栈是这么用的，这个栈保存这一行的数据，另一个栈保存下一行的数据，然后一行打印完后交替。
        // 方法一
        // 广度遍历的基础上加个临时数组，然后对偶数行的数据reverse也可以做
        // 因为是一层一层得遍历，会有个规律就是，当前层的数量，就是queue的长度！！！！！
        // 只需要判断奇偶，对偶数行的数据reverse再加入result中
        function Print(pRoot) {
            if (pRoot === null) {
                return [];
            }
            let re = [];
            let queue = [];
            queue.push(pRoot);
            let flag = false; // 是否为偶数，偶数行从右至左，需要reverse
            while (queue.length > 0) {
                let list = [];
                // 当前层的数量，就是queue的长度。遍历当前层，需要循环queue的当前长度
                let len = queue.length; // 需要提前获取长度，否则queue会一直变动
                for (let i = 0; i < len; i++) {
                    let node = queue.shift();
                    list.push(node.val);
                    if (node.left) {
                        queue.push(node.left);
                    }
                    if (node.right) {
                        queue.push(node.right);
                    }
                }
                if (flag) {
                    list.reverse();
                }
                // 注意，这里的结果返回，是一个不同每行长度不一致的二维数组
                // re.push(...list);
                re.push(list);
                flag = !flag;
            }
            return re;
        }
        // let tree = new Tree();
        // tree.add(4);
        // tree.add(2);
        // tree.add(5);
        // tree.add(1);
        // tree.add(3);
        // tree.add(6);
        // console.log(Print2(tree.root));



        // TODO: 60.把二叉树打印成多行
        // 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
        // 所谓每一层，就是当前queue中的结点就是当前层的。只要把这些都遍历一遍就是当前层的，而剩下添加进去的就是下一层的。
        function Print60(pRoot) {
            if (pRoot === null) {
                return [];
            }
            let re = [];
            let queue = [];
            queue.push(pRoot);
            while (queue.length > 0) {
                let list = [];
                // 当前层的数量，就是queue的长度。遍历当前层，需要循环queue的当前长度
                let len = queue.length; // 需要提前获取长度，否则queue会一直变动
                for (let i = 0; i < len; i++) {
                    let node = queue.shift();
                    list.push(node.val);
                    if (node.left) {
                        queue.push(node.left);
                    }
                    if (node.right) {
                        queue.push(node.right);
                    }
                }
                // 注意，这里的结果返回，是一个不同每行长度不一致的二维数组
                // re.push(...list);
                re.push(list);
            }
            return re;
        }

        // TODO: 61.序列化二叉树
        // 请实现两个函数，分别用来序列化和反序列化二叉树
        // 序列化主要就是在前后端交互时候需要转换下
        // 序列化比较简单，就是一个前序遍历的过程，而反序列化也不难发现，实际就是一个递归解决每个子树的问题，详见以下代码实现。
        // 需要用一个数组来进行传值！！！如果用str，那么数字11，22就无法保存了
        function Serialize(pRoot) {
            // 前序遍历
            if (pRoot === null) {
                return [];
            }
            let arr = []; // 利用指针传递
            _Serialize(pRoot, arr);
            return arr;
        }
        // 前序遍历
        function _Serialize(node, arr) {
            if (node === null) {
                arr.push("#");
                return;
            }
            arr.push(node.val);
            _Serialize(node.left, arr);
            _Serialize(node.right, arr);
        }
        function Deserialize(arr) {
            // 以为前序遍历，所以数组最前面的一定是根结点or父节点
            if (!arr || arr.length < 0) {
                return null;
            }
            // 利用指针传值
            return _Deserialize(arr);
        }
        function _Deserialize(arr) {
            // 以为前序遍历，所以数组最前面的一定是根结点or父节点
            if (!arr || arr.length <= 0) {
                return null;
            }
            let val = arr.shift();
            let node = null;
            if (val && val != '#') { // 注意，必须是val存在的时候！！！
                // 注意！！！这里的val是字符！！！需要转变为数字
                node = new TreeNode(val * 1);
                node.left = _Deserialize(arr);
                node.right = _Deserialize(arr);
            }
            // 如果val是#，那么就相当与返回null
            return node;
        }

        // let tree = new Tree();
        // tree.add(8);
        // tree.add(6);
        // tree.add(10);
        // tree.add(5);
        // tree.add(7);
        // tree.add(9);
        // tree.add(11);
        // let s = Serialize(tree.root);
        // console.log(s);
        // console.log(Deserialize(s));

        // TODO: 62.二叉搜索树的第k个结点
        // 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。
        // 在搜索二叉树中，最小值在左下角，最大值再右下角第k小。如果是找最大最小值，可以直接从左下角和右下角寻找。
        // 中序：从小到大的排列的数。
        function KthNode(pRoot, k) {
            // write code here
            if (pRoot === null || k < 1) {
                return;
            }
            return _KthNode(pRoot);
            // 为了能追踪k，应该把KthNodeCore函数定义在这里面，k应该在KthNodeCore函数外面
            function _KthNode(pRoot) {
                let target = null;
                // write code here
                if (pRoot === null) {
                    return;
                }
                if (pRoot.left) {
                    target = _KthNode(pRoot.left);
                }
                k--;
                if (k === 0) {
                    // target = pRoot.val;
                    target = pRoot;
                }
                if (pRoot.right && !target) { // 一旦target有值，就不需要继续赋值了！！！尤其右边
                    target = _KthNode(pRoot.right);
                }
                return target;
            }
        }
        // let tree = new Tree();
        // tree.add(4);
        // tree.add(2);
        // tree.add(5);
        // tree.add(1);
        // tree.add(3);
        // tree.add(6);
        // console.log(KthNode(tree.root, 2));

        // TODO: 63.数据流中的中位数
        // 使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。
        // 插入的时候保持数组一直有序。
        let arr63 = [];
        function Insert(num) {
            arr63.push(num);
            arr63.sort((a, b) => a - b); // 小到大
        }
        function GetMedian() {
            // write code here
            let len = arr63.length;
            if (len % 2 === 0) {
                return (arr63[len / 2 - 1] + arr63[len / 2]) / 2;
            } else {
                return arr63[parseInt(len / 2)];
            }
        }
        // Insert(1);
        // Insert(4);
        // Insert(5);
        // Insert(2);
        // Insert(3);
        // console.log(GetMedian());

        // TODO: 64.滑动窗口的最大值
        // 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
        // 滑动窗口，每次滑动就相当于一次出队！！！！！队列始终保持窗口大小的长度，每一次滑动就是出队入队
        // 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；
        function maxInWindows(num, size) {
            if (!num || num.length === 0 || size < 1) {
                return [];
            }
            let queue = num.slice(0, size);
            let re = [];
            let index = size; // 下一个需要入队的数（下标）
            while (index <= num.length) {
                let max = queue[0];
                // 获取当前窗口的最大值
                for (let i = 0; i < size; i++) {
                    if (queue[i] > max) {
                        max = queue[i];
                    }
                }
                re.push(max);
                queue.shift();
                queue.push(num[index]);
                index++;
            }
            return re;
        }
        // let arr =[2,3,4,2,6,2,5,1];
        // console.log(maxInWindows(arr,3));


        // TODO: 65.矩阵中的路径
        // 如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子
        // 思路，在二维数组中，每一个元素都遍历一遍，当前的元素就作为path的起始点，然后用递归回溯进行寻址。
        function hasPath(matrix, rows, cols, path) {
            // matrix是一个一维数组，需要自己去分行列
            let visited = []; // 是否遍历过
            let pathIndex = 0; // path的下标移动记录
            let pathLen = 0;
            for (let i = 0; i < matrix.length; i++) {
                visited[i] = false;
            }
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    // 每一个元素都遍历一次。
                    if (hasPathCore(i, j)) {
                        return true;
                    }
                }
            }
            return false;
            // 把函数写在函数内部，共用参数matrix,rows,cols
            function hasPathCore(i, j) {
                if (path.length === pathIndex) {
                    return true;
                }
                let re = false;
                if (i >= 0 && i <= rows && j >= 0 && j <= cols &&
                    path[pathIndex] === matrix[i * cols + j] && !visited[i * cols + j]) {
                    // 当前的二维数组[i][j]与当前路径相符，且为遍历过
                    pathIndex++; // 下标右移。判断下一个
                    visited[i * cols + j] = true;
                    // // 因为||为短路运算符，只要第一个满足就会返回，而不会去计算后面的，所以有些路径可以不用去走。
                    re = hasPathCore(i + 1, j) || hasPathCore(i - 1, j) ||
                        hasPathCore(i, j + 1) || hasPathCore(i, j - 1);
                    if (!re) {
                        // 如果此路不通，则需要回溯
                        pathIndex--;
                        visited[i * cols + j] = false;
                    }
                }
                return re;
            }
        }
        // let matrix = ['A', 'B', 'C', 'E', 'S', 'F', 'C', 'S', 'A', 'D', 'E', 'E'];
        // console.log(hasPath(matrix, 3, 4, ['A', 'B', 'C', 'A']));

        // TODO: 66.机器人的运动范围
        // 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 
        // 关于寻址问题，都可以使用回溯法！！！
        // 不过为了节约重复，可以每个用个数组保存每次遍历的结果（记录下哪个坐标是可以访问的）
        // 回溯法和暴力法有点类似，不过他会用数组或变量去记录已经遍历过的解，避免重复遍历，从而减少了计算量。
        function movingCount(threshold, rows, cols) {
            // write code here
            let visited = [];
            for (let i = 0; i < rows; i++) {
                visited[i] = [];
                for (let j = 0; j < cols; j++) {
                    visited[i][j] = false;
                }
            }
            return move(0, 0); // 从最开始的地方出发
            function move(i, j) {
                if (i < 0 || i >= rows || j < 0 || j >= cols || visited[i][j]) {
                    return 0; // 当前的格子不能进入，返回0
                }
                let sum = 0;
                let str = '' + i + j; // 数字合并，求数位之和
                for (let k = 0; k < str.length; k++) {
                    sum += str[k] * 1; // 转化成数字
                }
                if (sum > threshold) {
                    return 0; // 当前的格子不能进入，返回0
                }
                // 一下是当前格子可以进入
                visited[i][j] = true; // 当前格子设置为true，已经访问过
                // 当前格子可行所以+1，然后再加上四周格子的数量
                // 因为每个格子可以重复走！！！所以不用避讳。而且如果已经走过的格子会有visited记录，会返回0的
                return 1 + move(i + 1, j) + move(i - 1, j) + move(i, j + 1) + move(i, j - 1);
            }
        }
        // console.log(movingCount(5, 10, 10));

        // TODO: 67.剪绳子
        // 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1）请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？
        // 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
        // 动态规划f[n] = max(f(i)*f(n-i));
        // //因为要计算f(j)乘以f(i-j)的最大值,j超过i的一半时是重复计算
        function cutRope(number) {
            // 因为m、n都是整数，n>1并且m>1，也就是必须切！！！！
            // 在前三个的时候，一开始是切，但涉及后续的，就可以不切开了！！！
            if(number<2){
                return 0;
            }
            if (number === 2) {
                return 1;
            }
            if (number === 3) {
                return 2;
            }
            let re = [0, 1, 2, 3]; // 前三个是固定不变的

            // 从第四个开始
            for (let i = 4; i <= number; i++) {
                // 因为f(i)*f(n-i)，如果超过i/2就是重复计算了！如f(2)*f(8)和f(8)*f(2)
                let max = 0;
                for (let j = 1; j <= i / 2; j++) {
                    if (re[j] * re[i - j] > max) {
                        max = re[j] * re[i - j];
                    }
                }
                re[i] = max;
            }
            return re[number];
        }
        console.log(cutRope(2));
    </script>
</body>

</html>